import * as tus from 'tus-js-client';
import fetch from 'cross-fetch';
import { HttpError } from '../../../errors/dist/livepeer-core-errors.esm.js';
import { v as version } from '../../../dist/version-4e51e6db.esm.js';
import { d as defaultStudioConfig } from '../../../dist/provider-a18dabb6.esm.js';

class BaseLivepeerProvider {
  /** Provider base config */

  constructor(config) {
    this._config = config;
  }
  getConfig() {
    return this._config;
  }
  async _get(url, options) {
    const response = await fetch(`${this._config.baseUrl}${url}`, {
      method: 'GET',
      ...options,
      headers: {
        ...options?.headers,
        'x-core-sdk-version': version.core,
        'x-react-sdk-version': version.react,
        'x-react-native-sdk-version': version.reactNative
      }
    });
    if (!response.ok) {
      throw new HttpError(response.status, `Provider failed to get object from ${this._config.baseUrl}${url}, status code was ${response.status}`, await response.json());
    }
    return response.json();
  }
  async _create(url, options) {
    const response = await fetch(`${this._config.baseUrl}${url}`, {
      method: 'POST',
      ...options,
      ...(options?.json ? {
        body: JSON.stringify(options.json)
      } : {}),
      headers: {
        ...(options?.json ? {
          'content-type': 'application/json'
        } : {}),
        ...options?.headers,
        'x-core-sdk-version': version.core,
        'x-react-sdk-version': version.react,
        'x-react-native-sdk-version': version.reactNative
      }
    });
    if (!response.ok) {
      throw new HttpError(response.status, 'Provider failed to create object', await response.json());
    }
    return response.json();
  }
  async _update(url, options) {
    const response = await fetch(`${this._config.baseUrl}${url}`, {
      method: 'PATCH',
      ...options,
      ...(options?.json ? {
        body: JSON.stringify(options.json)
      } : {}),
      headers: {
        ...(options?.json ? {
          'content-type': 'application/json'
        } : {}),
        ...options?.headers,
        'x-core-sdk-version': version.core,
        'x-react-sdk-version': version.react,
        'x-react-native-sdk-version': version.reactNative
      }
    });
    if (!response.ok) {
      throw new HttpError(response.status, 'Provider failed to update object', await response.json());
    }
  }
}

const DEFAULT_CHUNK_SIZE = 100 * 1024 * 1024;
class StudioLivepeerProvider extends BaseLivepeerProvider {
  constructor(config) {
    super(config);
    this._defaultHeaders = {
      ...(config.apiKey ? {
        Authorization: `Bearer ${config.apiKey}`
      } : {}),
      ...(config.origin ? {
        Origin: config.origin
      } : {})
    };
  }
  async createStream(args) {
    const playbackPolicy = this._getPlaybackPolicyMapped(args.playbackPolicy);
    const studioStream = await this._create('/stream', {
      json: {
        ...args,
        ...(playbackPolicy ? {
          playbackPolicy
        } : {}),
        ...(args.creatorId ? {
          creatorId: args.creatorId
        } : {})
      },
      headers: this._defaultHeaders
    });
    return this._mapToStream(studioStream);
  }
  async updateStream(args) {
    const streamId = typeof args === 'string' ? args : args.streamId;
    const playbackPolicy = this._getPlaybackPolicyMapped(args.playbackPolicy);
    await this._update(`/stream/${streamId}`, {
      json: {
        ...(typeof args?.record !== 'undefined' ? {
          record: Boolean(args.record)
        } : {}),
        ...(typeof args?.suspend !== 'undefined' ? {
          suspended: Boolean(args.suspend)
        } : {}),
        ...(typeof args?.multistream?.targets !== 'undefined' ? {
          multistream: {
            targets: args.multistream.targets.map(t => typeof t.id === 'undefined' || 'url' in (t.spec ?? {}) ? {
              ...t,
              id: undefined
            } : {
              ...t,
              spec: undefined
            })
          }
        } : {}),
        ...(playbackPolicy ? {
          playbackPolicy
        } : {}),
        ...(args.creatorId ? {
          creatorId: args.creatorId
        } : {})
      },
      headers: this._defaultHeaders
    });
    return this.getStream(streamId);
  }
  async getStream(args) {
    const studioStream = await this._get(`/stream/${typeof args === 'string' ? args : args.streamId}`, {
      headers: this._defaultHeaders
    });
    return this._mapToStream(studioStream);
  }
  async getStreamSession(args) {
    const studioStreamSession = await this._get(`/session/${typeof args === 'string' ? args : args.streamSessionId}`, {
      headers: this._defaultHeaders
    });
    return studioStreamSession;
  }
  async getStreamSessions(args) {
    const studioStreamSessions = await this._get(`/stream/${typeof args === 'string' ? args : args.streamId}/sessions`, {
      headers: this._defaultHeaders
    });
    return studioStreamSessions;
  }
  async createClip(args) {
    const clip = await this._create(`/clip`, {
      json: {
        playbackId: args.playbackId,
        startTime: args.startTime,
        endTime: args.endTime,
        ...(args.name ? {
          name: args.name
        } : {}),
        ...(args.sessionId ? {
          sessionId: args.sessionId
        } : {})
      },
      headers: this._defaultHeaders
    });
    return clip.asset;
  }
  async createAsset(args) {
    const {
      sources,
      onProgress,
      noWait,
      chunkSize
    } = args;
    let progress = sources.map(source => ({
      name: source.name,
      progress: 0,
      assetId: null,
      phase: source?.url ? 'waiting' : 'uploading'
    }));

    // upload all assets and do not throw for failed
    const pendingAssetIds = await Promise.allSettled(sources.map(async (source, index) => {
      const playbackPolicy = this._getPlaybackPolicyMapped(source.playbackPolicy);
      if (source.url) {
        const createdAsset = await this._create('/asset/upload/url', {
          json: {
            name: source.name,
            url: source.url,
            storage: source?.storage?.ipfs ? {
              ipfs: {
                spec: {
                  nftMetadata: source?.storage?.metadata ?? {},
                  ...(source?.storage?.metadataTemplate ? {
                    nftMetadataTemplate: source.storage.metadataTemplate
                  } : {})
                }
              }
            } : undefined,
            ...(playbackPolicy ? {
              playbackPolicy
            } : {}),
            ...(source.creatorId ? {
              creatorId: source.creatorId
            } : {})
          },
          headers: this._defaultHeaders
        });
        return createdAsset?.asset?.id;
      } else {
        const uploadReq = await this._create('/asset/request-upload', {
          json: {
            name: source.name,
            storage: source?.storage?.ipfs ? {
              ipfs: {
                spec: {
                  nftMetadata: source?.storage?.metadata ?? {},
                  ...(source?.storage?.metadataTemplate ? {
                    nftMetadataTemplate: source.storage.metadataTemplate
                  } : {})
                }
              }
            } : undefined,
            ...(playbackPolicy ? {
              playbackPolicy
            } : {}),
            ...(source.creatorId ? {
              creatorId: source.creatorId
            } : {})
          },
          headers: this._defaultHeaders
        });
        const {
          tusEndpoint,
          asset: {
            id: assetId
          }
        } = uploadReq;
        await new Promise((resolve, reject) => {
          const upload = new tus.Upload(source.file, {
            endpoint: tusEndpoint,
            metadata: {
              id: assetId
            },
            ...(chunkSize ? {
              chunkSize
            } : typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative' ? null : {
              chunkSize: DEFAULT_CHUNK_SIZE
            }),
            // fingerprint: function (file: File & { exif?: any }) {
            //   return fingerprint(file);
            // },
            onError: error => {
              console.log('Failed because: ', error);
            },
            // TODO add configurable url storage for nodejs
            onProgress(bytesSent, bytesTotal) {
              const progressPercent = bytesSent / bytesTotal;
              const status = {
                name: source.name,
                assetId,
                progress: progressPercent,
                phase: 'uploading'
              };
              const newSources = [...progress];
              newSources[index] = status;
              progress = newSources;
              onProgress?.(progress);
            },
            onSuccess() {
              resolve();
            }
          });
          upload.findPreviousUploads().then(previousUploads => {
            if (previousUploads?.length > 0 && previousUploads[0]) {
              upload.resumeFromPreviousUpload(previousUploads[0]);
            }
            upload.start();
          }).catch(reject);
        });
        return assetId;
      }
    }));
    if (noWait) {
      return Promise.all(pendingAssetIds.map(async assetIdResult => {
        if (assetIdResult.status === 'rejected') {
          throw assetIdResult.reason;
        }
        return this.getAsset(assetIdResult.value);
      }));
    }
    const MAX_ERROR_COUNT = 5;

    // wait for all assets to complete uploading before returning
    const assets = await Promise.allSettled(pendingAssetIds.map(async (assetIdResult, index) => {
      if (assetIdResult.status === 'rejected') {
        throw assetIdResult.reason;
      }
      let asset = null;
      let errorCount = 0;
      while (asset?.status?.phase !== 'ready' && asset?.status?.phase !== 'failed') {
        try {
          // wait w/ random jitter
          await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 4000));
          asset = await this.getAsset(assetIdResult.value);
          if (typeof asset.status?.phase !== 'undefined') {
            const status = {
              name: asset.name,
              assetId: asset.id,
              progress: asset.status.progress ?? 0,
              phase: asset.status.phase
            };
            const newSources = [...progress];
            newSources[index] = status;
            progress = newSources;
            onProgress?.(progress);
          } else {
            throw new Error('Asset phase was undefined.');
          }
        } catch (e) {
          // hits the max error limit and throws the error
          if (errorCount > MAX_ERROR_COUNT) {
            throw e;
          }
          errorCount += 1;
        }
      }
      const status = {
        name: asset.name,
        assetId: asset.id,
        progress: 1,
        phase: asset.status.phase
      };
      const newSources = [...progress];
      newSources[index] = status;
      progress = newSources;
      onProgress?.(progress);
      return asset;
    }));
    const mappedAssets = [...assets.map(asset => {
      if (asset.status === 'fulfilled') {
        return asset.value;
      } else {
        throw asset.reason;
      }
    })];
    return mappedAssets;
  }
  async getAsset(args) {
    const studioAsset = await this._get(`/asset/${typeof args === 'string' ? args : args.assetId}`, {
      headers: this._defaultHeaders
    });
    return studioAsset;
  }
  async updateAsset(args) {
    const {
      assetId,
      name,
      storage
    } = args;
    const playbackPolicy = this._getPlaybackPolicyMapped(args.playbackPolicy);
    await this._update(`/asset/${assetId}`, {
      json: {
        name: typeof name !== 'undefined' ? String(name) : undefined,
        storage: storage?.ipfs ? {
          ipfs: {
            spec: {
              nftMetadata: storage?.metadata ?? {},
              ...(storage?.metadataTemplate ? {
                nftMetadataTemplate: storage.metadataTemplate
              } : {})
            }
          }
        } : undefined,
        ...(playbackPolicy ? {
          playbackPolicy
        } : {}),
        ...(args.creatorId ? {
          creatorId: args.creatorId
        } : {})
      },
      headers: this._defaultHeaders
    });
    return this.getAsset({
      assetId
    });
  }
  _getRtmpIngestUrl(streamKey) {
    return `rtmp://rtmp.livepeer.com/live/${streamKey}`;
  }
  async getPlaybackInfo(args) {
    const playbackId = typeof args === 'string' ? args : args.playbackId;
    const urlEncodedPlaybackId = encodeURIComponent(playbackId);
    const studioPlaybackInfo = await this._get(`/playback/${urlEncodedPlaybackId}?recordings=true`, {
      headers: this._defaultHeaders
    });
    return this._mapToPlaybackInfo(studioPlaybackInfo);
  }
  _getPlaybackUrl(playbackId) {
    return `https://livepeercdn.com/hls/${playbackId}/index.m3u8`;
  }
  async getAssetMetrics(args) {
    const assetId = typeof args === 'string' ? args : args.assetId;
    const studioViewsMetrics = await this._get(`/data/views/${assetId}/total`, {
      headers: this._defaultHeaders
    });
    return this._mapToViewsMetrics(studioViewsMetrics);
  }
  async _mapToStream(studioStream) {
    return {
      ...studioStream,
      multistream: await this._mapToMultistream(studioStream.multistream)
    };
  }
  async _mapToMultistream(studioMultistream) {
    if (!studioMultistream?.targets) {
      return undefined;
    }
    const fetchTargets = studioMultistream.targets.map(async t => {
      const {
        name
      } = await this._get(`/multistream/target/${t.id}`, {
        headers: this._defaultHeaders
      });
      return {
        ...t,
        spec: {
          name
        }
      };
    });
    return {
      targets: await Promise.all(fetchTargets)
    };
  }
  _mapToPlaybackInfo(studioPlaybackInfo) {
    return {
      type: studioPlaybackInfo?.['type'],
      meta: {
        ...studioPlaybackInfo?.['meta'],
        live: Boolean(studioPlaybackInfo?.['meta']?.['live']),
        source: studioPlaybackInfo?.['meta']?.['source']?.map(source => ({
          ...source
        })),
        attestation: studioPlaybackInfo?.['meta']?.['attestation']
      }
    };
  }
  _mapToViewsMetrics(studioMetrics) {
    return {
      type: 'ViewsMetrics',
      metrics: studioMetrics
    };
  }
  _getPlaybackPolicyMapped(policy) {
    return policy && typeof policy?.type !== 'undefined' ? policy.type === 'webhook' ? {
      type: policy.type,
      webhookId: policy.webhookId,
      webhookContext: policy.webhookContext
    } : {
      type: policy.type
    } : null;
  }
}
function studioProvider(config) {
  return () => new StudioLivepeerProvider({
    ...defaultStudioConfig,
    ...config
  });
}

export { StudioLivepeerProvider, studioProvider };
