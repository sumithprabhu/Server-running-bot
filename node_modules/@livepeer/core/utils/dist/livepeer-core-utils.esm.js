export { d as deepMerge } from '../../dist/deepMerge-577dcbf6.esm.js';
export { o as omit, p as pick } from '../../dist/omick-8a6e6439.esm.js';
export { b as b64Decode, a as b64Encode, c as b64UrlDecode, d as b64UrlEncode } from '../../dist/string-9a973b0a.esm.js';
import { CID } from 'multiformats/cid';

// Arweave Protocol
const arweaveProtocolPattern = /^(ar):\/\/([^/?#]+)(.*)$/;

// Gateways
const pathGatewayPattern$1 = /^https:\/\/(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;
const subdomainGatewayPattern$1 = /^https:\/\/([^/]+)\.(arweave\.net|arweave\.dev)\/([^/?#]+)(.*)$/;

/**
 * Takes an Arweave URL and returns a formatted Arweave URL if it is valid.
 * _This does not allow paths, query params, or hash in the URL and will return null_.
 * It does not check if the hash is a correct base64 URL encoded SHA-256 hash
 *
 * @param possibleArweaveString A possible URL for an Arweave resource. Can be a gateway or Arweave protocol URL.
 * @returns The formatted Arweave URI with `ar://` protocol and hash. Returns null if the URL is not valid.
 */
const parseArweaveTxId = possibleArweaveString => {
  if (!possibleArweaveString) {
    return null;
  }
  const arweaveProtocolHash = possibleArweaveString.match(arweaveProtocolPattern)?.[2];
  const arweaveProtocolUrlIndicators = possibleArweaveString.match(arweaveProtocolPattern)?.[3];
  if (arweaveProtocolHash) {
    return formatReturnHash(arweaveProtocolHash, arweaveProtocolUrlIndicators);
  }
  const subdomainGatewayHash = possibleArweaveString.match(subdomainGatewayPattern$1)?.[3];
  const subdomainGatewayUrlIndicators = possibleArweaveString.match(subdomainGatewayPattern$1)?.[4];
  if (subdomainGatewayHash) {
    return formatReturnHash(subdomainGatewayHash, subdomainGatewayUrlIndicators);
  }
  const pathGatewayHash = possibleArweaveString.match(pathGatewayPattern$1)?.[2];
  const pathGatewayUrlIndicators = possibleArweaveString.match(pathGatewayPattern$1)?.[3];
  if (pathGatewayHash) {
    return formatReturnHash(pathGatewayHash, pathGatewayUrlIndicators);
  }
  return null;
};
const formatReturnHash = (hash, urlIndicators) => {
  const hashWithUrlIndicators = `${hash}${urlIndicators ?? ''}`;
  return {
    url: `ar://${hashWithUrlIndicators}`,
    id: hashWithUrlIndicators
  };
};

// IPFS CID (naive check for lack of URL indicators)
const ipfsCidPattern = /^([^/?#]+)$/;

// IPFS Protocol
const ipfsProtocolPattern = /^(ipfs):\/\/([^/?#]+)(.*)$/;

// Gateways
const pathGatewayPattern = /^https?:\/\/[^/]+\/(ipfs)\/([^/?#]+)(.*)$/;
const subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ipfs)\.[^/?#]+(.*)$/;

/**
 * Takes an IPFS CID or URL and returns a formatted IPFS URL if the CID/URL is valid.
 * _This does not allow paths, query params, or hash in the URL and will return null_.
 *
 * @param possibleIpfsString A possible URL for an IPFS resource. Can be a gateway or IPFS protocol URL.
 * @returns The formatted IPFS URI with protocol and CID. Returns null if the URL is not valid.
 */
const parseCid = possibleIpfsString => {
  if (!possibleIpfsString) {
    return null;
  }
  const ipfsProtocolCid = possibleIpfsString.match(ipfsProtocolPattern)?.[2];
  const ipfsProtocolUrlIndicators = possibleIpfsString.match(ipfsProtocolPattern)?.[3];
  if (isCid(ipfsProtocolCid)) {
    return formatReturnCid(ipfsProtocolCid, ipfsProtocolUrlIndicators);
  }
  const subdomainGatewayCid = possibleIpfsString.match(subdomainGatewayPattern)?.[1];
  const subdomainGatewayUrlIndicators = possibleIpfsString.match(subdomainGatewayPattern)?.[3];
  if (isCid(subdomainGatewayCid)) {
    return formatReturnCid(subdomainGatewayCid, subdomainGatewayUrlIndicators);
  }
  const pathGatewayCid = possibleIpfsString.match(pathGatewayPattern)?.[2];
  const pathGatewayUrlIndicators = possibleIpfsString.match(pathGatewayPattern)?.[3];
  if (isCid(pathGatewayCid)) {
    return formatReturnCid(pathGatewayCid, pathGatewayUrlIndicators);
  }
  const ipfsCid = possibleIpfsString.match(ipfsCidPattern)?.[1];
  if (isCid(ipfsCid)) {
    return formatReturnCid(ipfsCid);
  }
  return null;
};
const isCid = hash => {
  try {
    if (!hash) {
      return false;
    }
    if (typeof hash === 'string') {
      return Boolean(CID.parse(hash));
    }
    if (hash instanceof Uint8Array) {
      return Boolean(CID.decode(hash));
    }
    return Boolean(CID.asCID(hash));
  } catch {
    return false;
  }
};
const formatReturnCid = (cid, urlIndicators) => {
  const cidWithUrlIndicators = `${cid}${urlIndicators ?? ''}`;
  return {
    url: `ipfs://${cidWithUrlIndicators}`,
    id: cidWithUrlIndicators
  };
};

const noop = (..._args) => {
  //
};
const notEqual = (valueA, valueB) => {
  // This ensures (valueB==NaN, valueA==NaN) always returns false.
  return valueB !== valueA && (valueB === valueB || valueA === valueA);
};
const equal = (valueA, valueB) => {
  return !notEqual(valueA, valueB);
};
const isNull = value => {
  return value === null;
};
const isUndefined = value => {
  return typeof value === 'undefined';
};
const isNil = value => {
  return isNull(value) || isUndefined(value);
};
const isObject = value => {
  return value?.constructor === Object;
};
const isNumber = value => {
  return typeof value === 'number' && !Number.isNaN(value);
};
const isString = value => {
  return typeof value === 'string';
};
const isBoolean = value => {
  return typeof value === 'boolean';
};

// eslint-disable-next-line @typescript-eslint/ban-types
const isFunction = value => {
  return typeof value === 'function';
};
const isArray = value => {
  return Array.isArray(value);
};
const isWindow = value => {
  return value === window;
};

const cache = new Set();
function warn(message, id) {
  if (!cache.has(id ?? message)) {
    console.warn(message);
    cache.add(message);
  }
}

export { equal, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, notEqual, parseArweaveTxId, parseCid, warn };
