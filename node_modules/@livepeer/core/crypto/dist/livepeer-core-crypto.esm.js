import ms from 'ms';
import { c as b64UrlDecode, b as b64Decode, d as b64UrlEncode } from '../../dist/string-9a973b0a.esm.js';
import { a as createClient } from '../../dist/client-8a4dc167.esm.js';
import { a as getStream } from '../../dist/getStream-fd5ec1b5.esm.js';
import 'zustand/middleware';
import 'zustand/vanilla';

const getSubtleCrypto = async () => {
  if (typeof window !== 'undefined') {
    if (window?.crypto?.subtle) {
      return window.crypto.subtle;
    }
    throw new Error('Browser is not in a secure context (HTTPS), cannot use SubtleCrypto: https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto');
  } else {
    const crypto = await import('node:crypto');
    return crypto.webcrypto.subtle;
  }
};

const signEcdsaSha256 = async (privateKey, data) => {
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.sign({
    name: 'ECDSA',
    hash: {
      name: 'SHA-256'
    }
  }, privateKey, data);
};

const importPKCS8 = async pkcs8 => {
  if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {
    throw new TypeError('"pkcs8" must be PKCS8 formatted string');
  }
  const privateKeyContents = b64UrlDecode(pkcs8.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''));
  if (!privateKeyContents) {
    throw new TypeError('Could not base64 decode private key contents.');
  }
  const subtleCrypto = await getSubtleCrypto();
  return subtleCrypto.importKey('pkcs8', new Uint8Array(privateKeyContents?.split('').map(c => c.charCodeAt(0))), {
    name: 'ECDSA',
    namedCurve: 'P-256'
  }, false, ['sign']);
};

/**
 * Signs a JSON Web Token which can be used to view access-restricted media. If you have not instantiated a client yet,
 * will throw a "No livepeer client found." error if no `config` is passed.
 *
 * Throws if there is an error fetching a stream by ID.
 */
const signAccessJwt = async (options, config) => {
  // assume strings passed are PEM-encoded PKCS8 (or base64 encoded)
  // try to coerce the input from base64, or use as-is
  const privateKey = typeof options.privateKey === 'string' ? await importPKCS8(b64Decode(options.privateKey) ?? options.privateKey) : options.privateKey;
  if (!privateKey) {
    throw new Error('Error importing private key.');
  }
  let playbackId = options?.playbackId;
  if (options?.streamId) {
    if (config) {
      createClient(config);
    }
    const stream = await getStream({
      streamId: options.streamId
    });
    playbackId = stream.playbackId;
  }
  if (!playbackId) {
    throw new Error('Playback ID was not provided and stream playback ID could not be fetched.');
  }
  const issuedAtSec = Date.now() / 1000;
  const expirationSec = issuedAtSec + ms(options.expiration ?? '1d') / 1000;
  const payload = {
    action: 'pull',
    iss: options.issuer,
    pub: options.publicKey,
    sub: playbackId,
    video: 'none',
    exp: Number(expirationSec.toFixed(0)),
    iat: Number(issuedAtSec.toFixed(0)),
    ...(options.custom ? {
      custom: {
        ...options.custom
      }
    } : {})
  };
  const header = {
    alg: 'ES256',
    typ: 'JWT'
  };
  const base64Header = b64UrlEncode(JSON.stringify(header));
  const base64Payload = b64UrlEncode(JSON.stringify(payload));
  const body = `${base64Header}.${base64Payload}`;
  const signatureBuffer = await signEcdsaSha256(privateKey, Buffer.from(body));
  const signature = b64UrlEncode(String.fromCharCode(...new Uint8Array(signatureBuffer)));
  return `${base64Header}.${base64Payload}.${signature}`;
};

export { importPKCS8, signAccessJwt };
