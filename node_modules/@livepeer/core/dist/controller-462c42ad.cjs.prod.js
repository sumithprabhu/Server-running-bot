'use strict';

var middleware = require('zustand/middleware');
var vanilla = require('zustand/vanilla');
var omick = require('./omick-75157746.cjs.prod.js');

const getMimeType = ending => {
  for (const value of Object.keys(mime)) {
    if (mime[value]?.some(v => v === ending)) {
      return value;
    }
  }
  return null;
};
const mime = {
  'application/mp4': ['mp4s', 'm4p'],
  'application/ogg': ['ogx'],
  'application/vnd.apple.mpegurl': ['m3u8'],
  'audio/3gpp': ['*3gpp'],
  'audio/adpcm': ['adp'],
  'audio/amr': ['amr'],
  'audio/basic': ['au', 'snd'],
  'audio/midi': ['mid', 'midi', 'kar', 'rmi'],
  'audio/mobile-xmf': ['mxmf'],
  'audio/mp3': ['*mp3'],
  'audio/mp4': ['m4a', 'mp4a'],
  'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
  'audio/ogg': ['oga', 'ogg', 'spx', 'opus'],
  'audio/s3m': ['s3m'],
  'audio/silk': ['sil'],
  'audio/vnd.dece.audio': ['uva', 'uvva'],
  'audio/vnd.digital-winds': ['eol'],
  'audio/vnd.dra': ['dra'],
  'audio/vnd.dts.hd': ['dtshd'],
  'audio/vnd.dts': ['dts'],
  'audio/vnd.lucent.voice': ['lvp'],
  'audio/vnd.ms-playready.media.pya': ['pya'],
  'audio/vnd.nuera.ecelp4800': ['ecelp4800'],
  'audio/vnd.nuera.ecelp7470': ['ecelp7470'],
  'audio/vnd.nuera.ecelp9600': ['ecelp9600'],
  'audio/vnd.rip': ['rip'],
  'audio/wav': ['wav'],
  'audio/wave': ['*wav'],
  'audio/webm': ['weba'],
  'audio/x-aac': ['aac'],
  'audio/x-aiff': ['aif', 'aiff', 'aifc'],
  'audio/x-caf': ['caf'],
  'audio/x-flac': ['flac'],
  'audio/x-m4a': ['*m4a'],
  'audio/x-matroska': ['mka'],
  'audio/x-mpegurl': ['m3u'],
  'audio/x-ms-wax': ['wax'],
  'audio/x-ms-wma': ['wma'],
  'audio/x-pn-realaudio-plugin': ['rmp'],
  'audio/x-pn-realaudio': ['ram', 'ra'],
  'audio/x-realaudio': ['*ra'],
  'audio/x-wav': ['*wav'],
  'audio/xm': ['xm'],
  'video/3gpp': ['3gp', '3gpp'],
  'video/3gpp2': ['3g2'],
  'video/h261': ['h261'],
  'video/h263': ['h263'],
  'video/h264': ['h264'],
  'video/iso.segment': ['m4s'],
  'video/jpeg': ['jpgv'],
  'video/jpm': ['*jpm', 'jpgm'],
  'video/mj2': ['mj2', 'mjp2'],
  'video/mp2t': ['ts'],
  'video/mp4': ['mp4', 'mp4v', 'mpg4'],
  'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
  'video/ogg': ['ogv'],
  'video/quicktime': ['qt', 'mov'],
  'video/vnd.dece.hd': ['uvh', 'uvvh'],
  'video/vnd.dece.mobile': ['uvm', 'uvvm'],
  'video/vnd.dece.pd': ['uvp', 'uvvp'],
  'video/vnd.dece.sd': ['uvs', 'uvvs'],
  'video/vnd.dece.video': ['uvv', 'uvvv'],
  'video/vnd.dvb.file': ['dvb'],
  'video/vnd.fvt': ['fvt'],
  'video/vnd.mpegurl': ['mxu', 'm4u'],
  'video/vnd.ms-playready.media.pyv': ['pyv'],
  'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],
  'video/vnd.vivo': ['viv'],
  'video/vp8': ['vp8'],
  'video/webm': ['webm'],
  'video/x-f4v': ['f4v'],
  'video/x-fli': ['fli'],
  'video/x-flv': ['flv'],
  'video/x-m4v': ['m4v'],
  'video/x-matroska': ['mkv', 'mk3d', 'mks'],
  'video/x-mng': ['mng'],
  'video/x-ms-asf': ['asf', 'asx'],
  'video/x-ms-vob': ['vob'],
  'video/x-ms-wm': ['wm'],
  'video/x-ms-wmv': ['wmv'],
  'video/x-ms-wmx': ['wmx'],
  'video/x-ms-wvx': ['wvx'],
  'video/x-msvideo': ['avi'],
  'video/x-sgi-movie': ['movie'],
  'video/x-smv': ['smv']
};

const audioExtensions = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
const videoExtensions = /\.(mp4|ogv|webm|mov|m4v|avi|m3u8)($|\?)/i;
const base64String = /data:video/i;
const hlsExtensions = /\.(m3u8)($|\?)/i;
const webrtcExtensions = /(webrtc|sdp)/i;
const mimeFromBase64Pattern = /data:(.+?);base64/;
const getMediaSourceType = src => {
  const base64Mime = src.match(mimeFromBase64Pattern);
  return webrtcExtensions.test(src) ? {
    type: 'webrtc',
    src: src,
    mime: 'video/h264'
  } : hlsExtensions.test(src) ? {
    type: 'hls',
    src: src,
    mime: getMimeType(hlsExtensions.exec(src)?.[1] ?? '')
  } : videoExtensions.test(src) ? {
    type: 'video',
    src: src,
    mime: getMimeType(videoExtensions.exec(src)?.[1] ?? '')
  } : audioExtensions.test(src) ? {
    type: 'audio',
    src: src,
    mime: getMimeType(audioExtensions.exec(src)?.[1] ?? '')
  } : base64String.test(src) ? {
    type: 'video',
    src: src,
    mime: base64Mime ? base64Mime[1] : 'video/mp4'
  } : null;
};

const DEFAULT_SEEK_TIME = 5000; // milliseconds which the media will skip when seeking with arrows/buttons
const DEFAULT_VOLUME_LEVEL = 1; // 0-1 for how loud the audio is

const DEFAULT_AUTOHIDE_TIME = 3000; // milliseconds to wait before hiding controls

const ASSET_URL_PART_VALUE = 'hls';
const WEBRTC_URL_PART_VALUE = 'webrtc';
const RECORDING_URL_PART_VALUE = 'recordings';
const getPlaybackIdFromSourceUrl = sourceUrl => {
  const parsedUrl = new URL(sourceUrl);
  const parts = parsedUrl.pathname.split('/');
  const includesAssetUrl = parts.includes(ASSET_URL_PART_VALUE);
  const includesWebRtcUrl = parts.includes(WEBRTC_URL_PART_VALUE);
  const includesRecording = parts.includes(RECORDING_URL_PART_VALUE);

  // Check if the url is valid
  const playbackId = includesWebRtcUrl ? parts?.[(parts?.length ?? 0) - 1] : includesRecording || includesAssetUrl ? parts?.[(parts?.length ?? 0) - 2] ?? null : null;
  return playbackId;
};
const omittedKeys = ['_lastInteraction', '_requestSeekDiff', '_requestedFullscreenLastTime', '_requestedPictureInPictureLastTime', '_requestedPlayPauseLastTime', '_requestedRangeToSeekTo', '_playLastTime', '_setVolume', '_updateBuffered', '_updateLastInteraction', '_updateMediaStream', '_updateSource', 'setIsVolumeChangeSupported', 'setError', 'setWebsocketMetadata', 'setStalled', 'setWaiting', 'onProgress', 'onDurationChange', 'onPlay', 'onPause', 'onClipCreated', 'onClipError', 'onClipStarted', '_updatePlaybackOffsetMs'];
const sanitizeMediaControllerState = state => omick.omit(state, ...omittedKeys);
const getFilteredNaN = value => value && !isNaN(value) && isFinite(value) ? value : 0;
const getBoundedSeek = (seek, duration) => Math.min(Math.max(0, getFilteredNaN(seek)),
// seek to near the end
getFilteredNaN(duration) ? getFilteredNaN(duration) - 0.01 : 0);
const getBoundedVolume = volume => Math.min(Math.max(0, getFilteredNaN(volume)), 1);
const createControllerStore = ({
  element,
  device,
  storage,
  mediaProps,
  opts
}) => {
  const store = vanilla.createStore(middleware.subscribeWithSelector(middleware.persist((set, get) => ({
    _element: element ?? null,
    canPlay: false,
    hidden: false,
    live: false,
    ingestUrl: mediaProps.ingestUrl ?? null,
    playbackId: mediaProps.playbackId ?? null,
    src: null,
    autoplay: Boolean(mediaProps.autoPlay),
    muted: Boolean(mediaProps.muted),
    priority: Boolean(mediaProps.priority),
    preload: mediaProps.priority ? 'full' : 'none',
    viewerId: mediaProps.viewerId ?? '',
    creatorId: mediaProps.creatorId ?? '',
    clipLength: mediaProps.clipLength,
    onClipCreated: mediaProps.onClipCreated,
    onClipError: mediaProps.onClipError,
    onClipStarted: mediaProps.onClipStarted,
    playbackOffsetMs: 0,
    deviceIds: null,
    hasPlayed: false,
    playing: false,
    fullscreen: false,
    pictureInPicture: false,
    waiting: false,
    stalled: false,
    loading: false,
    playbackRate: 1,
    _mediaStream: null,
    video: null,
    device,
    progress: 0,
    duration: 0,
    buffered: 0,
    volume: getBoundedVolume(opts?.defaultVolume ?? DEFAULT_VOLUME_LEVEL),
    isVolumeChangeSupported: false,
    _lastInteraction: Date.now(),
    _requestedRangeToSeekTo: 0,
    _requestedClipLastTime: Date.now(),
    _requestedFullscreenLastTime: Date.now(),
    _requestedPictureInPictureLastTime: Date.now(),
    _requestedPlayPauseLastTime: 0,
    _playLastTime: 0,
    _updateMediaStream: (_mediaStream, ids) => set(({
      deviceIds
    }) => ({
      _mediaStream,
      ...(ids?.video ? {
        video: true
      } : {}),
      deviceIds: {
        ...deviceIds,
        ...(ids?.audio ? {
          audio: ids.audio
        } : {}),
        ...(ids?.video ? {
          video: ids.video
        } : {})
      }
    })),
    setHidden: hidden => set(({
      playing
    }) => ({
      hidden: playing ? hidden : false
    })),
    _updateLastInteraction: () => set(() => ({
      _lastInteraction: Date.now(),
      hidden: false
    })),
    // set the src and playbackId from the source URL
    _updateSource: source => set(({
      playbackId
    }) => ({
      src: getMediaSourceType(source),
      ...(!playbackId ? {
        playbackId: getPlaybackIdFromSourceUrl(source)
      } : {})
    })),
    _updatePlaybackOffsetMs: offset => set(() => ({
      playbackOffsetMs: offset
    })),
    onCanPlay: () => set(() => ({
      canPlay: true,
      loading: false
    })),
    onPlay: () => set(() => ({
      playing: true,
      hasPlayed: true,
      stalled: false,
      waiting: false,
      _playLastTime: Date.now()
    })),
    onPause: () => set(() => ({
      playing: false,
      hidden: false,
      // TODO check if these should be getting set when pause event is fired (this was pulled from metrics)
      stalled: false,
      waiting: false
    })),
    togglePlay: force => {
      const {
        hidden,
        setHidden,
        device
      } = store.getState();
      if (!force && hidden && device.isMobile) {
        setHidden(false);
      } else {
        set(() => ({
          _requestedPlayPauseLastTime: Date.now(),
          _lastInteraction: Date.now()
        }));
      }
    },
    toggleVideo: () => set(({
      video
    }) => ({
      video: !video
    })),
    onProgress: time => set(() => ({
      progress: getFilteredNaN(time),
      waiting: false,
      stalled: false
    })),
    requestSeek: time => set(({
      duration
    }) => ({
      _requestedRangeToSeekTo: getBoundedSeek(time, duration),
      progress: getBoundedSeek(time, duration)
    })),
    onDurationChange: duration => set(({
      live
    }) => ({
      duration,
      live: duration === Number.POSITIVE_INFINITY ? true : live
    })),
    setWebsocketMetadata: metadata => set(() => ({
      metadata
    })),
    _updateBuffered: buffered => set(() => ({
      buffered
    })),
    _requestSeekDiff: difference => set(({
      progress,
      duration
    }) => ({
      _requestedRangeToSeekTo: getBoundedSeek(getFilteredNaN(progress) + difference / 1000, duration)
    })),
    requestSeekBack: (difference = DEFAULT_SEEK_TIME) => get()._requestSeekDiff(-difference),
    requestSeekForward: (difference = DEFAULT_SEEK_TIME) => get()._requestSeekDiff(difference),
    setSize: size => set(() => ({
      size
    })),
    setWaiting: waiting => set(() => ({
      waiting
    })),
    setError: error => set(() => ({
      error
    })),
    setStalled: stalled => set(() => ({
      stalled
    })),
    setLoading: loading => set(() => ({
      loading
    })),
    setFullscreen: fullscreen => set(() => ({
      fullscreen
    })),
    requestToggleFullscreen: () => set(() => ({
      _requestedFullscreenLastTime: Date.now()
    })),
    requestClip: () => set(() => ({
      _requestedClipLastTime: Date.now()
    })),
    setPictureInPicture: pictureInPicture => set(() => ({
      pictureInPicture
    })),
    requestTogglePictureInPicture: () => set(() => ({
      _requestedPictureInPictureLastTime: Date.now()
    })),
    setLive: live => set(() => ({
      live
    })),
    requestVolume: newVolume => set(({
      volume
    }) => ({
      volume: newVolume === 0 ? volume : getBoundedVolume(newVolume),
      muted: newVolume === 0
    })),
    _setVolume: newVolume => set(() => ({
      volume: getBoundedVolume(newVolume)
    })),
    requestToggleMute: () => set(({
      muted
    }) => ({
      muted: !muted
    })),
    setIsVolumeChangeSupported: supported => set(() => ({
      isVolumeChangeSupported: supported
    }))
  }), {
    name: 'livepeer-player',
    version: 1,
    // since these values are persisted across media, only persist volume and playbackRate
    partialize: ({
      volume,
      playbackRate
    }) => ({
      volume,
      playbackRate
    }),
    storage: middleware.createJSONStorage(() => storage)
  })));
  return store;
};

exports.DEFAULT_AUTOHIDE_TIME = DEFAULT_AUTOHIDE_TIME;
exports.DEFAULT_VOLUME_LEVEL = DEFAULT_VOLUME_LEVEL;
exports.createControllerStore = createControllerStore;
exports.getMediaSourceType = getMediaSourceType;
exports.sanitizeMediaControllerState = sanitizeMediaControllerState;
