import { StoreApi } from 'zustand/vanilla';
import { Src } from './src';
import { ClientStorage } from '../storage';
import { Asset } from '../types';
export declare const DEFAULT_VOLUME_LEVEL = 1;
export declare const DEFAULT_AUTOHIDE_TIME = 3000;
export type DeviceInformation = {
    version: string;
    isMobile: boolean;
    isIos: boolean;
    isAndroid: boolean;
    userAgent: string;
};
export type MediaSizing = {
    container?: ElementSize;
    media?: ElementSize;
};
export type ElementSize = {
    width: number;
    height: number;
};
export type Metadata = {
    bframes?: number;
    bufferWindow?: number;
};
export type ClipLength = 90 | 60 | 45 | 30 | 15 | 10;
declare const omittedKeys: readonly ["_lastInteraction", "_requestSeekDiff", "_requestedFullscreenLastTime", "_requestedPictureInPictureLastTime", "_requestedPlayPauseLastTime", "_requestedRangeToSeekTo", "_playLastTime", "_setVolume", "_updateBuffered", "_updateLastInteraction", "_updateMediaStream", "_updateSource", "setIsVolumeChangeSupported", "setError", "setWebsocketMetadata", "setStalled", "setWaiting", "onProgress", "onDurationChange", "onPlay", "onPause", "onClipCreated", "onClipError", "onClipStarted", "_updatePlaybackOffsetMs"];
export declare const sanitizeMediaControllerState: <TElement, TMediaStream>(state: MediaControllerState<TElement, TMediaStream>) => MediaControllerCallbackState<TElement, TMediaStream>;
export type MediaControllerCallbackState<TElement = HTMLMediaElement, TMediaStream = MediaStream> = Omit<MediaControllerState<TElement, TMediaStream>, typeof omittedKeys[number]>;
export type MediaControllerState<TElement = void, TMediaStream = void> = {
    /** If the media has loaded and can be played */
    canPlay: boolean;
    /** If the controls are currently hidden */
    hidden: boolean;
    /** The last time that the media was interacted with */
    _lastInteraction: number;
    /** Current volume of the media */
    volume: number;
    /** If media is muted */
    muted: boolean;
    /** If media supports changing the volume */
    isVolumeChangeSupported: boolean;
    /** The playbackId that was passed in to the media element */
    playbackId: string | null;
    /** The Source that was passed in to the Player */
    src: Src | null;
    /** The ingest URL that was passed in to the broadcast component */
    ingestUrl: string | null;
    /** If autoplay was passed in to the media element */
    autoplay: boolean;
    /** If priority was passed in to the media element */
    priority: boolean;
    /** The preload option passed in to the media element */
    preload: 'full' | 'metadata' | 'none';
    /** The viewerId for the viewer passed in to Player */
    viewerId: string;
    /** The creatorId for the broadcast component */
    creatorId: string;
    /** The media metadata, from the playback websocket */
    metadata?: Metadata;
    /** The length (in seconds) of the clip to create from instant clipping. */
    clipLength?: ClipLength;
    /** Callback when a clip is created from the clip button. */
    onClipStarted?: () => Promise<any> | any;
    /** Callback when a clip is created from the clip button. */
    onClipCreated?: (asset: Asset) => Promise<any> | any;
    /** Callback when a clip fails to be created from the clip button. */
    onClipError?: (error: any) => Promise<any> | any;
    /** The offset of the browser's livestream versus the server time (in ms). */
    playbackOffsetMs?: number;
    /** The audio and video device IDs for broadcasting */
    deviceIds: {
        audio?: string;
        video?: string;
    } | null;
    /** If the media is current playing or paused */
    playing: boolean;
    /** If the media has been played yet */
    hasPlayed: boolean;
    /** If the media is fullscreen */
    fullscreen: boolean;
    /** The playback rate for the media */
    playbackRate: number;
    /** If the media has an error */
    error?: string;
    /** If the media is currently waiting for data */
    waiting: boolean;
    /** If the media is currently stalled */
    stalled: boolean;
    /** If the media is currently loading */
    loading: boolean;
    /** If the media is in picture in picture mode */
    pictureInPicture: boolean;
    /** The last time that play/pause was requested */
    _requestedPlayPauseLastTime: number;
    /** The last time that fullscreen was changed */
    _requestedFullscreenLastTime: number;
    /** The last time that a clip was requested */
    _requestedClipLastTime: number;
    /** The last time that picture in picture was changed*/
    _requestedPictureInPictureLastTime: number;
    /** The last time that a play event was received */
    _playLastTime: number;
    /** If the content is live media */
    live: boolean;
    /** Current progress of the media */
    progress: number;
    /** Current total duration of the media */
    duration: number;
    /** Current buffered end time for the media */
    buffered: number;
    /** Internal value when a user requests an update to the progress of the media */
    _requestedRangeToSeekTo: number;
    /** Internal element used for playing media */
    _element: TElement | null;
    /** Internal MediaStream used for broadcasting */
    _mediaStream: TMediaStream | null;
    /** If video is enabled (only applies to broadcasting) */
    video: boolean | null;
    /** Media sizing information */
    size?: MediaSizing;
    /** Device tracking set on load of the media */
    device: DeviceInformation;
    _updateSource: (source: string) => void;
    _updateMediaStream: (mediaStream: TMediaStream, ids?: {
        audio?: string;
        video?: string;
    }) => void;
    setHidden: (hidden: boolean) => void;
    _updateLastInteraction: () => void;
    _updatePlaybackOffsetMs: (offset: number) => void;
    setWebsocketMetadata: (metadata: Metadata) => void;
    onCanPlay: () => void;
    onPlay: () => void;
    onPause: () => void;
    togglePlay: (force?: boolean) => void;
    toggleVideo: () => void;
    onProgress: (time: number) => void;
    onDurationChange: (duration: number) => void;
    _updateBuffered: (buffered: number) => void;
    requestSeek: (time: number) => void;
    requestSeekBack: (difference?: number) => void;
    requestSeekForward: (difference?: number) => void;
    _requestSeekDiff: (difference: number) => void;
    setLive: (live: boolean) => void;
    setSize: (size: MediaSizing) => void;
    setFullscreen: (fullscreen: boolean) => void;
    setPictureInPicture: (pictureInPicture: boolean) => void;
    requestToggleFullscreen: () => void;
    requestTogglePictureInPicture: () => void;
    requestClip: () => void;
    _setVolume: (volume: number) => void;
    requestVolume: (volume: number) => void;
    requestToggleMute: () => void;
    setIsVolumeChangeSupported: (supported: boolean) => void;
    setWaiting: (waiting: boolean) => void;
    setError: (error: string) => void;
    setStalled: (stalled: boolean) => void;
    setLoading: (stalled: boolean) => void;
};
export type MediaControllerStore<TElement, TMediaStream> = StoreApi<MediaControllerState<TElement, TMediaStream>> & {
    subscribe: {
        (listener: (selectedState: MediaControllerState<TElement, TMediaStream>, previousSelectedState: MediaControllerState<TElement, TMediaStream>) => void): () => void;
        <U>(selector: (state: MediaControllerState<TElement, TMediaStream>) => U, listener: (selectedState: U, previousSelectedState: U) => void, options?: {
            equalityFn?: (a: U, b: U) => boolean;
            fireImmediately?: boolean;
        }): () => void;
    };
};
export declare const createControllerStore: <TElement, TMediaStream>({ element, device, storage, mediaProps, opts, }: {
    element?: TElement | undefined;
    device: DeviceInformation;
    storage: ClientStorage;
    mediaProps: MediaPropsOptions;
    opts: ControlsOptions;
}) => MediaControllerStore<TElement, TMediaStream>;
export type ControlsOptions = {
    /** Auto-hide controls after a set amount of time (in milliseconds). Defaults to 3000. Set to 0 for no hiding. */
    autohide?: number;
    /** Sets the default volume. Must be between 0 and 1. */
    defaultVolume?: number;
};
export type MediaPropsOptions = {
    playbackId?: string;
    autoPlay?: boolean;
    muted?: boolean;
    priority?: boolean;
    viewerId?: string;
    clipLength?: ClipLength;
    onClipStarted?: () => Promise<any> | any;
    onClipCreated?: (asset: Asset) => Promise<any> | any;
    onClipError?: (error: any) => Promise<any> | any;
    creatorId?: string;
    ingestUrl?: string;
};
export {};
