"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataModifier = void 0;
const pushStreamTypes_1 = require("./pushStreamTypes");
const types_1 = require("../types");
const constants_1 = require("../payloads/constants");
class DataModifier {
    static handleChatGroupEvent(data, includeRaw = false) {
        switch (data.eventType) {
            case 'create':
                return this.mapToCreateGroupEvent(data, includeRaw);
            case 'update':
                return this.mapToUpdateGroupEvent(data, includeRaw);
            case pushStreamTypes_1.GroupEventType.JoinGroup:
                return this.mapToJoinGroupEvent(data, includeRaw);
            case pushStreamTypes_1.GroupEventType.LeaveGroup:
                return this.mapToLeaveGroupEvent(data, includeRaw);
            case pushStreamTypes_1.MessageEventType.Request:
                return this.mapToRequestEvent(data, includeRaw);
            case pushStreamTypes_1.GroupEventType.Remove:
                return this.mapToRemoveEvent(data, includeRaw);
            default:
                console.warn('Unknown eventType:', data.eventType);
                return data;
        }
    }
    static mapToJoinGroupEvent(data, includeRaw) {
        const baseEventData = {
            origin: data.messageOrigin,
            timestamp: data.timestamp,
            chatId: data.chatId,
            from: data.from,
            to: data.to,
            event: pushStreamTypes_1.GroupEventType.JoinGroup,
        };
        return includeRaw
            ? Object.assign(Object.assign({}, baseEventData), { raw: { verificationProof: data.verificationProof } }) : baseEventData;
    }
    static mapToLeaveGroupEvent(data, includeRaw) {
        const baseEventData = {
            origin: data.messageOrigin,
            timestamp: data.timestamp,
            chatId: data.chatId,
            from: data.from,
            to: data.to,
            event: pushStreamTypes_1.GroupEventType.LeaveGroup,
        };
        return includeRaw
            ? Object.assign(Object.assign({}, baseEventData), { raw: { verificationProof: data.verificationProof } }) : baseEventData;
    }
    static mapToRequestEvent(data, includeRaw) {
        const eventData = {
            origin: data.messageOrigin,
            timestamp: data.timestamp,
            chatId: data.chatId,
            from: data.from,
            to: data.to,
            event: pushStreamTypes_1.MessageEventType.Request,
            meta: {
                group: data.isGroup || false,
            },
        };
        if (includeRaw) {
            eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
    }
    static mapToRemoveEvent(data, includeRaw) {
        // Whatever the structure of your RemoveEvent, modify accordingly
        const eventData = {
            origin: data.messageOrigin,
            timestamp: data.timestamp,
            chatId: data.chatId,
            from: data.from,
            to: data.to,
            event: pushStreamTypes_1.GroupEventType.Remove,
        };
        if (includeRaw) {
            eventData.raw = { verificationProof: data.verificationProof };
        }
        return eventData;
    }
    static buildChatGroupEventMetaAndRaw(incomingData, includeRaw) {
        const meta = {
            name: incomingData.groupName,
            description: incomingData.groupDescription,
            image: incomingData.groupImage,
            owner: incomingData.groupCreator,
            private: !incomingData.isPublic,
            rules: incomingData.rules || {},
        };
        if (includeRaw) {
            const raw = {
                verificationProof: incomingData.verificationProof,
            };
            return { meta, raw };
        }
        return { meta };
    }
    static mapToGroupEvent(eventType, incomingData, includeRaw) {
        const { meta, raw } = this.buildChatGroupEventMetaAndRaw(incomingData, includeRaw);
        const groupEvent = {
            event: eventType,
            origin: incomingData.messageOrigin,
            timestamp: incomingData.timestamp,
            chatId: incomingData.chatId,
            from: incomingData.from,
            meta,
        };
        if (includeRaw) {
            groupEvent.raw = raw;
        }
        return groupEvent;
    }
    static mapToCreateGroupEvent(incomingData, includeRaw) {
        return this.mapToGroupEvent(pushStreamTypes_1.GroupEventType.CreateGroup, incomingData, includeRaw);
    }
    static mapToUpdateGroupEvent(incomingData, includeRaw) {
        return this.mapToGroupEvent(pushStreamTypes_1.GroupEventType.UpdateGroup, incomingData, includeRaw);
    }
    static mapToMessageEvent(data, includeRaw = false, eventType) {
        if (data.hasIntent === false && eventType === 'message') {
            eventType = pushStreamTypes_1.MessageEventType.Request;
        }
        const messageEvent = {
            event: eventType,
            origin: data.messageOrigin,
            timestamp: data.timestamp.toString(),
            chatId: data.chatId,
            from: data.fromCAIP10,
            to: [data.toCAIP10],
            message: {
                type: data.messageType,
                content: data.messageContent,
            },
            meta: {
                group: data.isGroup || false,
            },
            reference: data.cid,
        };
        if (includeRaw) {
            const rawData = {
                fromCAIP10: data.fromCAIP10,
                toCAIP10: data.toCAIP10,
                fromDID: data.fromDID,
                toDID: data.toDID,
                encType: data.encType,
                encryptedSecret: data.encryptedSecret,
                signature: data.signature,
                sigType: data.sigType,
                verificationProof: data.verificationProof,
                previousReference: data.link,
            };
            messageEvent.raw = rawData;
        }
        return messageEvent;
    }
    static handleChatEvent(data, includeRaw = false) {
        if (!data) {
            console.error('Error in handleChatEvent: data is undefined or null');
            throw new Error('data is undefined or null');
        }
        const eventTypeMap = {
            Chat: pushStreamTypes_1.MessageEventType.Message,
            Request: pushStreamTypes_1.MessageEventType.Request,
            Approve: pushStreamTypes_1.MessageEventType.Accept,
            Reject: pushStreamTypes_1.MessageEventType.Reject,
        };
        const key = data.eventType || data.messageCategory;
        if (!eventTypeMap[key]) {
            console.error('Error in handleChatEvent: Invalid eventType or messageCategory', JSON.stringify(data));
            throw new Error('Invalid eventType or messageCategory in data');
        }
        const eventType = eventTypeMap[key];
        if (eventType) {
            return this.mapToMessageEvent(data, includeRaw, eventType);
        }
        else {
            console.warn('Unknown eventType:', data.eventType || data.messageCategory);
            return data;
        }
    }
    static mapToNotificationEvent(data, notificationEventType, origin, includeRaw = false) {
        var _a, _b, _c;
        const notificationType = Object.keys(pushStreamTypes_1.NOTIFICATION.TYPE).find((key) => pushStreamTypes_1.NOTIFICATION.TYPE[key] === data.payload.data.type) || 'BROADCAST'; // Assuming 'BROADCAST' as the default
        let recipients;
        if (Array.isArray(data.payload.recipients)) {
            recipients = data.payload.recipients;
        }
        else if (typeof data.payload.recipients === 'string') {
            recipients = [data.payload.recipients];
        }
        else {
            recipients = Object.keys(data.payload.recipients);
        }
        const notificationEvent = {
            event: notificationEventType,
            origin: origin,
            timestamp: data.epoch,
            from: data.sender,
            to: recipients,
            notifID: data.payload_id.toString(),
            channel: {
                name: data.payload.data.app,
                icon: data.payload.data.icon,
                url: data.payload.data.url,
            },
            meta: {
                type: 'NOTIFICATION.' + notificationType,
            },
            message: {
                notification: {
                    title: data.payload.notification.title,
                    body: data.payload.notification.body,
                },
                payload: {
                    title: data.payload.data.asub,
                    body: data.payload.data.amsg,
                    cta: data.payload.data.acta,
                    embed: data.payload.data.aimg,
                    meta: {
                        domain: ((_a = data.payload.data.additionalMeta) === null || _a === void 0 ? void 0 : _a.domain) || 'push.org',
                        type: (_b = data.payload.data.additionalMeta) === null || _b === void 0 ? void 0 : _b.type,
                        data: (_c = data.payload.data.additionalMeta) === null || _c === void 0 ? void 0 : _c.data,
                    },
                },
            },
            config: {
                expiry: data.payload.data.etime,
                silent: data.payload.data.silent === '1',
                hidden: data.payload.data.hidden === '1',
            },
            source: data.source,
        };
        if (includeRaw) {
            notificationEvent.raw = {
                verificationProof: data.payload.verificationProof,
            };
        }
        return notificationEvent;
    }
    static convertToProposedName(currentEventName) {
        switch (currentEventName) {
            case 'message':
                return pushStreamTypes_1.ProposedEventNames.Message;
            case 'request':
                return pushStreamTypes_1.ProposedEventNames.Request;
            case 'accept':
                return pushStreamTypes_1.ProposedEventNames.Accept;
            case 'reject':
                return pushStreamTypes_1.ProposedEventNames.Reject;
            case 'leaveGroup':
                return pushStreamTypes_1.ProposedEventNames.LeaveGroup;
            case 'joinGroup':
                return pushStreamTypes_1.ProposedEventNames.JoinGroup;
            case 'createGroup':
                return pushStreamTypes_1.ProposedEventNames.CreateGroup;
            case 'updateGroup':
                return pushStreamTypes_1.ProposedEventNames.UpdateGroup;
            case 'remove':
                return pushStreamTypes_1.ProposedEventNames.Remove;
            default:
                throw new Error(`Unknown current event name: ${currentEventName}`);
        }
    }
    static handleToField(data) {
        var _a;
        switch (data.event) {
            case pushStreamTypes_1.ProposedEventNames.LeaveGroup:
            case pushStreamTypes_1.ProposedEventNames.JoinGroup:
                data.to = null;
                break;
            case pushStreamTypes_1.ProposedEventNames.Accept:
            case pushStreamTypes_1.ProposedEventNames.Reject:
                if ((_a = data.meta) === null || _a === void 0 ? void 0 : _a.group) {
                    data.to = null;
                }
                break;
            default:
                break;
        }
    }
    static convertToProposedNameForVideo(currentVideoStatus) {
        switch (currentVideoStatus) {
            case types_1.VideoCallStatus.INITIALIZED:
                return pushStreamTypes_1.VideoEventType.REQUEST;
            case types_1.VideoCallStatus.RECEIVED:
                return pushStreamTypes_1.VideoEventType.APPROVE;
            case types_1.VideoCallStatus.CONNECTED:
                return pushStreamTypes_1.VideoEventType.CONNECT;
            case types_1.VideoCallStatus.ENDED:
                return pushStreamTypes_1.VideoEventType.DISCONNECT;
            case types_1.VideoCallStatus.DISCONNECTED:
                return pushStreamTypes_1.VideoEventType.DENY;
            case types_1.VideoCallStatus.RETRY_INITIALIZED:
                return pushStreamTypes_1.VideoEventType.RETRY_REQUEST;
            case types_1.VideoCallStatus.RETRY_RECEIVED:
                return pushStreamTypes_1.VideoEventType.RETRY_APPROVE;
            default:
                throw new Error(`Unknown video call status: ${currentVideoStatus}`);
        }
    }
    static mapToVideoEvent(data, origin, includeRaw = false) {
        var _a, _b;
        const { senderAddress, signalData, status, chatId } = JSON.parse((_a = data.payload.data.additionalMeta) === null || _a === void 0 ? void 0 : _a.data);
        // To maintain backward compatibility, if the rules object is not present in the payload,
        // we create a new rules object with chatId from additionalMeta.data
        const rules = (_b = data.payload.rules) !== null && _b !== void 0 ? _b : {
            access: {
                type: constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT,
                data: {
                    chatId,
                },
            },
        };
        const peerInfo = {
            address: senderAddress,
            signal: signalData,
            meta: {
                rules,
            },
        };
        const videoEventType = DataModifier.convertToProposedNameForVideo(status);
        const videoEvent = {
            event: videoEventType,
            origin: origin,
            timestamp: data.epoch,
            peerInfo,
        };
        if (includeRaw) {
            videoEvent.raw = {
                verificationProof: data.payload.verificationProof,
            };
        }
        return videoEvent;
    }
}
exports.DataModifier = DataModifier;
//# sourceMappingURL=DataModifier.js.map