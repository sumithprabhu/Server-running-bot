"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop = void 0;
const tslib_1 = require("tslib");
const helpers_1 = require("../chat/helpers");
const updateGroup_1 = require("../chat/updateGroup");
const get_1 = require("./get");
const types_1 = require("../types");
const constants_1 = require("../payloads/constants");
function stop() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            // should be only called by the host
            const space = yield (0, get_1.get)({
                spaceId: this.spaceSpecificData.spaceId,
                env: this.env,
            });
            if (space.status === types_1.ChatStatus.ENDED) {
                throw new Error('Space already ended');
            }
            const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
            const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
            const group = yield (0, updateGroup_1.updateGroup)({
                chatId: this.spaceSpecificData.spaceId,
                groupName: space.spaceName,
                groupImage: space.spaceImage,
                groupDescription: space.spaceDescription,
                members: convertedMembers,
                admins: convertedAdmins,
                signer: this.signer,
                env: this.env,
                pgpPrivateKey: this.pgpPrivateKey,
                scheduleAt: space.scheduleAt,
                scheduleEnd: space.scheduleEnd,
                status: types_1.ChatStatus.ENDED,
            });
            // update space specific data
            this.setSpaceSpecificData(() => (Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { liveSpaceData: this.spaceSpecificData.liveSpaceData })));
            // stop livepeer playback
            /*
              - disconnect with every incoming peer in the mesh connection
              - other peers should also end their connections as we want to destroy the mesh connection
            */
            this.data.incoming.slice(1).forEach(({ address }) => {
                this.disconnect({
                    peerAddress: address,
                    details: {
                        type: constants_1.SPACE_DISCONNECT_TYPE.STOP,
                        data: {},
                    },
                });
            });
        }
        catch (err) {
            console.error(`[Push SDK] - API  - Error - API ${stop.name} -:  `, err);
            throw Error(`[Push SDK] - API  - Error - API ${stop.name} -: ${err}`);
        }
    });
}
exports.stop = stop;
//# sourceMappingURL=stop.js.map