"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const helpers_1 = require("./../chat/helpers");
const get_1 = require("./get");
const updateGroup_1 = require("../chat/updateGroup");
const immer_1 = require("immer");
const helpers_2 = require("../helpers");
const messageTypes_1 = require("../types/messageTypes");
const sendLiveSpaceData_1 = require("./helpers/sendLiveSpaceData");
// export async function start(this: Space, options: StartType): Promise<void> {
function start() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // const { livepeerApiKey } = options || {};
        try {
            // host should have there audio stream
            // if (!this.data.local.stream) {
            //   throw new Error('Local audio stream not found');
            // }
            const space = yield (0, get_1.get)({
                spaceId: this.spaceSpecificData.spaceId,
                env: this.env,
            });
            if (space.status !== types_1.ChatStatus.PENDING) {
                throw new Error('Unable to start the space as it is not in the pending state');
            }
            // Only host is allowed to start a space
            if (this.data.local.address !== (0, helpers_2.pCAIP10ToWallet)(space.spaceCreator)) {
                throw new Error('Only host is allowed to start a space');
            }
            const convertedMembers = (0, helpers_1.getSpacesMembersList)(space.members, space.pendingMembers);
            const convertedAdmins = (0, helpers_1.getSpaceAdminsList)(space.members, space.pendingMembers);
            const group = yield (0, updateGroup_1.updateGroup)({
                chatId: this.spaceSpecificData.spaceId,
                groupName: space.spaceName,
                groupImage: space.spaceImage,
                groupDescription: space.spaceDescription,
                members: convertedMembers,
                admins: convertedAdmins,
                signer: this.signer,
                env: this.env,
                pgpPrivateKey: this.pgpPrivateKey,
                scheduleAt: space.scheduleAt,
                scheduleEnd: space.scheduleEnd,
                status: types_1.ChatStatus.ACTIVE,
            });
            const liveSpaceData = {
                host: {
                    address: this.data.local.address,
                    audio: this.data.local.audio,
                    emojiReactions: null,
                },
                coHosts: [],
                speakers: [],
                listeners: [],
            };
            yield (0, sendLiveSpaceData_1.default)({
                liveSpaceData,
                action: messageTypes_1.CHAT.META.SPACE.CREATE,
                spaceId: this.spaceSpecificData.spaceId,
                signer: this.signer,
                pgpPrivateKey: this.pgpPrivateKey,
                env: this.env,
            });
            // update space data
            this.setSpaceData((oldSpaceData) => {
                return (0, immer_1.produce)(oldSpaceData, (draft) => {
                    draft = Object.assign(Object.assign({}, (0, helpers_1.groupDtoToSpaceDto)(group)), { liveSpaceData, connectionData: draft.connectionData });
                    draft.connectionData.meta.broadcast = {
                        livepeerInfo: null,
                        hostAddress: this.data.local.address,
                    };
                });
            });
            // // start the livepeer playback and store the playback URL group meta
            // // send a notification/meta message to all the added listeners (members) telling the space has started
            // // create the mergeStream object
            // const mergedStream = getMergeStreamObject(this.data.local.stream);
            // // store the mergeStreamObject
            // this.mergedStream = mergedStream;
            // const url = 'https://livepeer.studio/api/stream';
            // const data = {
            //   name: this.spaceSpecificData.spaceName,
            //   record: true,
            // };
            // const { data: responseData } = await axios.post(url, data, {
            //   headers: {
            //     Authorization: 'Bearer ' + livepeerApiKey,
            //   },
            // });
            // const { streamKey, playbackId } = responseData;
            // this.update({ meta: playbackId });
            // let redirectUrl;
            // try {
            //   // the redirect URL from the above GET request
            //   await axios.get(`https://livepeer.studio/webrtc/${streamKey}`);
            // } catch (err: any) {
            //   redirectUrl = err.request.responseURL;
            // }
            // // we use the host from the redirect URL in the ICE server configuration
            // const host = new URL(redirectUrl).host;
            // const iceServers = [
            //   {
            //     urls: `stun:${host}`,
            //   },
            //   {
            //     urls: `turn:${host}`,
            //     username: 'livepeer',
            //     credential: 'livepeer',
            //   },
            // ];
            // const peerConnection = new RTCPeerConnection({ iceServers });
            // const newAudioTrack = mergedStream.result?.getAudioTracks?.()?.[0] ?? null;
            // if (newAudioTrack) {
            //   peerConnection?.addTransceiver(newAudioTrack, {
            //     direction: 'sendonly',
            //   });
            // }
            // /**
            //  * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createOffer
            //  * We create an SDP offer here which will be shared with the server
            //  */
            // const offer = await peerConnection.createOffer();
            // /** https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/setLocalDescription */
            // await peerConnection.setLocalDescription(offer);
            // /** Wait for ICE gathering to complete */
            // const ofr = await new Promise<RTCSessionDescription | null>((resolve) => {
            //   /** Wait at most five seconds for ICE gathering. */
            //   setTimeout(() => {
            //     resolve(peerConnection.localDescription);
            //   }, 5000);
            //   peerConnection.onicegatheringstatechange = (_ev) => {
            //     if (peerConnection.iceGatheringState === 'complete') {
            //       resolve(peerConnection.localDescription);
            //     }
            //   };
            // });
            // if (!ofr) {
            //   throw Error('failed to gather ICE candidates for offer');
            // }
            // /**
            //  * This response contains the server's SDP offer.
            //  * This specifies how the client should communicate,
            //  * and what kind of media client and server have negotiated to exchange.
            //  */
            // const sdpResponse = await fetch(redirectUrl, {
            //   method: 'POST',
            //   mode: 'cors',
            //   headers: {
            //     'content-type': 'application/sdp',
            //   },
            //   body: ofr.sdp,
            // });
            // if (sdpResponse.ok) {
            //   const answerSDP = await sdpResponse.text();
            //   await peerConnection.setRemoteDescription(
            //     new RTCSessionDescription({ type: 'answer', sdp: answerSDP })
            //   );
            // }
        }
        catch (err) {
            console.error(`[Push SDK] - API  - Error - API ${start.name} -:  `, err);
            throw Error(`[Push SDK] - API  - Error - API ${start.name} -: ${err}`);
        }
    });
}
exports.start = start;
//# sourceMappingURL=start.js.map