"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.join = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../payloads/constants");
const types_1 = require("../types");
const approve_1 = require("./approve");
const get_1 = require("./get");
const getIncomingIndexFromAddress_1 = require("../video/helpers/getIncomingIndexFromAddress");
const getPlainAddress_1 = require("./helpers/getPlainAddress");
/**
 *
 * @param options
 *  recievedVideoData: only required when joining as a speaker
 */
function join() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const space = yield (0, get_1.get)({
                spaceId: this.spaceSpecificData.spaceId,
                env: this.env,
            });
            if (space.status !== types_1.ChatStatus.ACTIVE)
                throw new Error('Space not active yet');
            // checking what is the current role of caller address
            let isSpeaker = false;
            let isListner = false;
            const localAddress = (0, getPlainAddress_1.default)(this.data.local.address);
            space.members.forEach((member) => {
                if ((0, getPlainAddress_1.default)(member.wallet) === localAddress) {
                    if (member.isSpeaker) {
                        isSpeaker = true;
                    }
                    else {
                        isListner = true;
                    }
                }
            });
            let isSpeakerPending = false;
            space.pendingMembers.forEach((pendingMember) => {
                if ((0, getPlainAddress_1.default)(pendingMember.wallet) === localAddress &&
                    pendingMember.isSpeaker) {
                    isSpeakerPending = true;
                }
            });
            const hostAddress = (0, getPlainAddress_1.default)(space.spaceCreator);
            const incomingIndex = (0, getIncomingIndexFromAddress_1.default)(this.data.incoming, hostAddress);
            // check if we arent already connected to the host
            if ((isSpeaker || isSpeakerPending) && incomingIndex > -1) {
                return Promise.resolve();
            }
            // acc to the found role (speaker or listner), executing req logic
            // if speaker is pending then approve first or if listner is pending/not found then approve first
            if (!isSpeaker && !isListner) {
                yield (0, approve_1.approve)({
                    signer: this.signer,
                    pgpPrivateKey: this.pgpPrivateKey,
                    senderAddress: this.spaceSpecificData.spaceId,
                    env: this.env,
                });
            }
            if (isSpeaker || isSpeakerPending) {
                // Call the host and join the mesh connection
                yield this.request({
                    senderAddress: this.data.local.address,
                    recipientAddress: hostAddress,
                    chatId: this.spaceSpecificData.spaceId,
                    details: {
                        type: constants_1.SPACE_REQUEST_TYPE.JOIN_SPEAKER,
                        data: {},
                    },
                });
            }
            const updatedSpace = yield (0, get_1.get)({
                spaceId: this.spaceSpecificData.spaceId,
                env: this.env,
            });
            // update space specific data
            this.setSpaceSpecificData(() => (Object.assign(Object.assign({}, updatedSpace), { liveSpaceData: this.spaceSpecificData.liveSpaceData })));
        }
        catch (err) {
            console.error(`[Push SDK] - API  - Error - API ${join.name} -:  `, err);
            throw Error(`[Push SDK] - API  - Error - API ${join.name} -: ${err}`);
        }
    });
}
exports.join = join;
//# sourceMappingURL=join.js.map