"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.onJoinListener = void 0;
const tslib_1 = require("tslib");
const sendLiveSpaceData_1 = require("./helpers/sendLiveSpaceData");
const get_1 = require("./get");
const helpers_1 = require("../helpers");
const immer_1 = require("immer");
const messageTypes_1 = require("../types/messageTypes");
function onJoinListener(options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { receivedAddress } = options || {};
        // method should be called only by the host
        if ((0, helpers_1.pCAIP10ToWallet)(this.spaceSpecificData.spaceCreator) !==
            this.data.local.address) {
            return;
        }
        // checking the role of the added address
        const updatedSpace = yield (0, get_1.get)({
            spaceId: this.spaceSpecificData.spaceId,
            env: this.env,
        });
        const isAddressListener = updatedSpace.members.find((member) => (0, helpers_1.pCAIP10ToWallet)(member.wallet) === (0, helpers_1.pCAIP10ToWallet)(receivedAddress) &&
            !member.isSpeaker);
        // if the address is not a listener then we dont fire a meta message
        if (!isAddressListener) {
            return;
        }
        // check if the listener is already present in the liveSpaceData
        const modifiedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
            const isListenerAlreadyAdded = this.spaceSpecificData.liveSpaceData.listeners.find((currentListener) => (0, helpers_1.pCAIP10ToWallet)(currentListener.address) ===
                (0, helpers_1.pCAIP10ToWallet)(receivedAddress));
            if (isListenerAlreadyAdded) {
                // listener is already added in the meta message
                // might be case when the listener has left the space
            }
            else {
                // adding new listener in the live space data
                draft.listeners.push({
                    address: (0, helpers_1.pCAIP10ToWallet)(receivedAddress),
                    handRaised: false,
                    emojiReactions: null,
                });
            }
        });
        this.setSpaceSpecificData(() => (Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: modifiedLiveSpaceData })));
        // firing a meta message
        yield (0, sendLiveSpaceData_1.default)({
            spaceId: this.spaceSpecificData.spaceId,
            pgpPrivateKey: this.pgpPrivateKey,
            env: this.env,
            signer: this.signer,
            liveSpaceData: modifiedLiveSpaceData,
            action: messageTypes_1.CHAT.META.SPACE.LISTENER.ADD,
        });
    });
}
exports.onJoinListener = onJoinListener;
//# sourceMappingURL=onJoinListener.js.map