"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Space = exports.initSpaceData = exports.initSpaceSpecificData = exports.initLiveSpaceData = void 0;
const tslib_1 = require("tslib");
const immer_1 = require("immer");
const constants_1 = require("../constants");
const video_1 = require("../video");
const update_1 = require("./update");
const start_1 = require("./start");
const inviteToPromote_1 = require("./inviteToPromote");
const acceptPromotionInvite_1 = require("./acceptPromotionInvite");
const connectInvitee_1 = require("./connectInvitee");
const rejectPromotionInvite_1 = require("./rejectPromotionInvite");
const requestToBePromoted_1 = require("./requestToBePromoted");
const acceptPromotionRequest_1 = require("./acceptPromotionRequest");
const rejectPromotionRequest_1 = require("./rejectPromotionRequest");
const connectPromotor_1 = require("./connectPromotor");
const join_1 = require("./join");
const leave_1 = require("./leave");
const stop_1 = require("./stop");
const initialize_1 = require("./initialize");
const addToMergedStream_1 = require("./helpers/addToMergedStream");
const types_1 = require("../types");
const constants_2 = require("../payloads/constants");
const sendLiveSpaceData_1 = require("./helpers/sendLiveSpaceData");
const messageTypes_1 = require("../types/messageTypes");
const broadcastRaisedHand_1 = require("./broadcastRaisedHand");
const onReceiveMetaMessage_1 = require("./onReceiveMetaMessage");
const onJoinListener_1 = require("./onJoinListener");
const helpers_1 = require("../helpers");
exports.initLiveSpaceData = {
    host: {
        address: '',
        audio: null,
        emojiReactions: null,
    },
    coHosts: [],
    speakers: [],
    listeners: [],
};
exports.initSpaceSpecificData = {
    members: [],
    pendingMembers: [],
    contractAddressERC20: null,
    numberOfERC20: -1,
    contractAddressNFT: null,
    numberOfNFTTokens: -1,
    verificationProof: '',
    spaceImage: null,
    spaceName: '',
    isPublic: false,
    spaceDescription: '',
    spaceCreator: '',
    spaceId: '',
    scheduleAt: null,
    scheduleEnd: null,
    status: null,
    inviteeDetails: {},
    liveSpaceData: exports.initLiveSpaceData,
};
exports.initSpaceData = Object.assign(Object.assign({}, exports.initSpaceSpecificData), { connectionData: video_1.initVideoCallData });
// declaring the Space class
class Space extends video_1.Video {
    constructor(options) {
        const { signer, pgpPrivateKey, address, chainId, env = constants_1.default.ENV.PROD, setSpaceData, // to update the 'spaceData' state maintained by the developer
         } = options || {};
        // init the Video class
        super({
            signer,
            chainId,
            pgpPrivateKey,
            env,
            callType: constants_2.VIDEO_CALL_TYPE.PUSH_SPACE,
            onReceiveStream: (receivedStream, senderAddress, audio) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                var _a;
                // for a space, that has started broadcast & the local peer is the host
                if (this.spaceSpecificData.status === types_1.ChatStatus.ACTIVE &&
                    ((_a = this.data.meta.broadcast) === null || _a === void 0 ? void 0 : _a.hostAddress) &&
                    this.data.meta.broadcast.hostAddress === this.data.local.address) {
                    (0, addToMergedStream_1.default)(this.mergedStream, receivedStream);
                    // update live space info
                    const updatedLiveSpaceData = (0, immer_1.produce)(this.spaceSpecificData.liveSpaceData, (draft) => {
                        // check if the address was a listener
                        const listenerIndex = this.spaceSpecificData.liveSpaceData.listeners.findIndex((listener) => listener.address === senderAddress);
                        // TODO: Create distinction between speakers and co hosts
                        draft.speakers.push({
                            address: senderAddress,
                            audio,
                            emojiReactions: listenerIndex > -1
                                ? this.spaceSpecificData.liveSpaceData.listeners[listenerIndex].emojiReactions
                                : null,
                        });
                        if (listenerIndex > -1)
                            draft.listeners.splice(listenerIndex, 1);
                    });
                    this.setSpaceSpecificData(() => (Object.assign(Object.assign({}, this.spaceSpecificData), { liveSpaceData: updatedLiveSpaceData })));
                    yield (0, sendLiveSpaceData_1.default)({
                        liveSpaceData: updatedLiveSpaceData,
                        pgpPrivateKey: this.pgpPrivateKey,
                        env: this.env,
                        spaceId: this.spaceSpecificData.spaceId,
                        signer: this.signer,
                        action: messageTypes_1.CHAT.META.GROUP.ADMIN.PRVILEGE, // TODO: Add a meta action for SPEAKER_JOINED
                    });
                }
            }),
            setData: function () {
                return;
            }, // setData will be overridden below
        });
        this.mergedStream = null;
        // adding instance methods
        this.initialize = initialize_1.initialize;
        this.update = update_1.update;
        this.createAudioStream = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.create({ audio: true, video: false });
        });
        this.start = start_1.start;
        this.onReceiveMetaMessage = onReceiveMetaMessage_1.onReceiveMetaMessage;
        // host will call this function from socket
        // will fire a meta message if a new listener has joined the space
        this.onJoinListener = onJoinListener_1.onJoinListener;
        // to promote a listener to a speaker/co-host
        this.inviteToPromote = inviteToPromote_1.inviteToPromote;
        this.acceptPromotionInvite = acceptPromotionInvite_1.acceptPromotionInvite;
        this.connectInvitee = connectInvitee_1.connectInvitee;
        this.rejectPromotionInvite = rejectPromotionInvite_1.rejectPromotionInvite;
        // listener requests to be promoted to a speaker
        this.requestToBePromoted = requestToBePromoted_1.requestToBePromoted;
        this.broadcastRaisedHand = broadcastRaisedHand_1.broadcastRaisedHand; // will be called by the host after receiving the request to be promoted
        this.acceptPromotionRequest = acceptPromotionRequest_1.acceptPromotionRequest;
        this.connectPromotor = connectPromotor_1.connectPromotor;
        this.rejectPromotionRequest = rejectPromotionRequest_1.rejectPromotionRequest;
        /*
          - add/remove co-host to the space group as admins
          - add/remove them from the meta message
          - these methods are only to be used when the space hasnt started yet
        */
        // public addCoHost = addCoHost;
        // public removeCoHost = removeCoHost;
        // add listner to the space group as member
        this.join = join_1.join;
        this.leave = leave_1.leave;
        this.stop = stop_1.stop;
        // setting state changing functions
        /*
          - Will be used internally in the class
          - Overriding setData (Video)
          - To be used when we only want to modify video call 'data'
        */
        this.setData = function (fn) {
            const newVideoData = fn(this.data);
            // update the react state
            setSpaceData(() => (Object.assign(Object.assign({}, this.spaceSpecificData), { connectionData: newVideoData })));
            // update the video class variable
            this.data = newVideoData;
        };
        /*
          - Will be used internally in the class
          - To be used when we only want to modify space specific 'data'
        */
        this.setSpaceSpecificData = function (fn) {
            const newSpaceSpecificData = fn(this.spaceSpecificData);
            // update the react state
            setSpaceData(() => (Object.assign(Object.assign({}, newSpaceSpecificData), { connectionData: this.data })));
            // update the video class variable
            this.spaceSpecificData = newSpaceSpecificData;
        };
        // set the space state updating function
        this.setSpaceData = function (fn) {
            const _a = fn(Object.assign(Object.assign({}, this.spaceSpecificData), { connectionData: this.data })), { connectionData: newConnectionData } = _a, newSpaceSpecificData = tslib_1.__rest(_a, ["connectionData"]);
            // update the space specific data
            this.spaceSpecificData = newSpaceSpecificData;
            // update the video data and update the external state
            this.setData(() => newConnectionData);
        };
        // initializing state
        // set the local address inside video call 'data'
        this.setData((oldVideoCallData) => {
            return (0, immer_1.produce)(oldVideoCallData, (draft) => {
                draft.local.address = (0, helpers_1.pCAIP10ToWallet)(address);
            });
        });
        // init the state maintained by the developer
        setSpaceData(() => exports.initSpaceData);
        // init the spaceSpecificData class variable
        this.spaceSpecificData = exports.initSpaceSpecificData;
    }
}
exports.Space = Space;
exports.default = Space;
//# sourceMappingURL=Space.js.map