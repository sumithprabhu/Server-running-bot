"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Notification = exports.FEED_MAP = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../constants");
const PushNotificationTypes_1 = require("./PushNotificationTypes");
const PUSH_USER = require("../user");
const PUSH_CHANNEL = require("../channels");
const helpers_1 = require("../helpers");
const pushNotificationBase_1 = require("./pushNotificationBase");
// ERROR CONSTANTS
const ERROR_CHANNEL_NEEDED = 'Channel is needed';
const ERROR_INVALID_CAIP = 'Invalid CAIP format';
exports.FEED_MAP = {
    INBOX: false,
    SPAM: true,
};
class Notification extends pushNotificationBase_1.PushNotificationBaseClass {
    constructor(signer, env, account) {
        super(signer, env, account);
        /**
         * @description - Fetches feeds and spam feeds for a specific user
         * @param {enums} spam - indicates if its a spam or not. `INBOX` for non-spam and `SPAM` for spam. default `INBOX`
         * @param {string} [options.user] - user address, defaults to address from signer
         * @param {number} [options.page] -  page number. default is set to Constants.PAGINATION.INITIAL_PAGE
         * @param {number} [options.limit] - number of feeds per page. default is set to Constants.PAGINATION.LIMIT
         * @param {boolean} [options.raw] - indicates if the response should be raw or formatted. defaults is set to false
         * @returns feeds for a specific address
         */
        this.list = (spam = PushNotificationTypes_1.FeedType.INBOX, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, channels = [], raw = false, } = options || {};
            try {
                const account = (options === null || options === void 0 ? void 0 : options.account)
                    ? options.account
                    : this.account
                        ? (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account)
                        : null;
                // guest mode and valid address check
                this.checkUserAddressExists(account);
                const nonCaipAccount = this.getAddressFromCaip(account);
                if (channels.length == 0) {
                    // else return the response
                    return yield PUSH_USER.getFeeds({
                        user: nonCaipAccount,
                        page: page,
                        limit: limit,
                        spam: exports.FEED_MAP[spam],
                        raw: raw,
                        env: this.env,
                    });
                }
                else {
                    const promises = channels.map((channel) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        return yield PUSH_USER.getFeedsPerChannel({
                            user: nonCaipAccount,
                            page: page,
                            limit: limit,
                            spam: exports.FEED_MAP[spam],
                            raw: raw,
                            env: this.env,
                            channels: [channel],
                        });
                    }));
                    const results = yield Promise.all(promises);
                    const feedRes = results.flat();
                    return feedRes;
                }
            }
            catch (error) {
                throw new Error(`Push SDK Error: API : notifcaiton::list : ${error}`);
            }
        });
        this.subscriptions = (options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { 
                // TODO: to be used once pagination is implemeted at API level
                page = constants_1.default.PAGINATION.INITIAL_PAGE, limit = constants_1.default.PAGINATION.LIMIT, } = options || {};
                const account = (options === null || options === void 0 ? void 0 : options.account)
                    ? options.account
                    : this.account
                        ? (0, helpers_1.getFallbackETHCAIPAddress)(this.env, this.account)
                        : null;
                this.checkUserAddressExists(account);
                return yield PUSH_USER.getSubscriptions({
                    user: account,
                    env: this.env,
                });
            }
            catch (error) {
                throw new Error(`Push SDK Error: API : notifcaiton::subscriptions : ${error}`);
            }
        });
        /**
         * Subscribes a user to a channel
         * @param {string} channel - channel address in caip format
         * @param {function} [options.onSuccess] - callback function when a user successfully subscribes to a channel
         * @param {function} [options.onError] - callback function incase a user was not able to subscribe to a channel
         * @returns Subscribe status object
         */
        this.subscribe = (channel, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { onSuccess, onError, settings } = options || {};
                // Vaidatiions
                // validates if signer object is present
                this.checkSignerObjectExists();
                // validates if the user address exists
                this.checkUserAddressExists();
                // validates if channel exists
                if (!channel && channel != '') {
                    throw new Error(ERROR_CHANNEL_NEEDED);
                }
                // validates if caip is correct
                if (!(0, helpers_1.validateCAIP)(channel)) {
                    throw new Error(ERROR_INVALID_CAIP);
                }
                // get channel caip
                const caipDetail = (0, helpers_1.getCAIPDetails)(channel);
                // based on the caip, construct the user caip
                const userAddressInCaip = (0, helpers_1.getCAIPWithChainId)(this.account, parseInt(caipDetail === null || caipDetail === void 0 ? void 0 : caipDetail.networkId));
                // convert the setting to minimal version
                const minimalSetting = this.getMinimalUserSetting(settings);
                return yield PUSH_CHANNEL.subscribeV2({
                    signer: this.signer,
                    channelAddress: channel,
                    userAddress: userAddressInCaip,
                    env: this.env,
                    settings: minimalSetting !== null && minimalSetting !== void 0 ? minimalSetting : '',
                    onSuccess: onSuccess,
                    onError: onError,
                });
            }
            catch (error) {
                throw new Error(`Push SDK Error: API : notifcaiton::subscribe : ${error}`);
            }
        });
        /**
         * Unsubscribes a user to a channel
         * @param {string} channel - channel address in caip format
         * @param {function} [options.onSuccess] - callback function when a user successfully unsubscribes to a channel
         * @param {function} [options.onError] - callback function incase a user was not able to unsubscribe to a channel
         * @returns Unsubscribe status object
         */
        this.unsubscribe = (channel, options) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const { onSuccess, onError } = options || {};
                // Vaidatiions
                // validates if the user address exists
                this.checkUserAddressExists();
                // validates if signer object is present
                this.checkSignerObjectExists();
                // validates if channel exists
                if (!channel && channel != '') {
                    return new Error(ERROR_CHANNEL_NEEDED);
                }
                // validates if caip is correct
                if (!(0, helpers_1.validateCAIP)(channel)) {
                    return new Error(ERROR_INVALID_CAIP);
                }
                const caipDetail = (0, helpers_1.getCAIPDetails)(channel);
                const userAddressInCaip = (0, helpers_1.getCAIPWithChainId)(this.account, parseInt(caipDetail === null || caipDetail === void 0 ? void 0 : caipDetail.networkId));
                return yield PUSH_CHANNEL.unsubscribeV2({
                    signer: this.signer,
                    channelAddress: channel,
                    userAddress: userAddressInCaip,
                    env: this.env,
                    onSuccess: onSuccess,
                    onError: onError,
                });
            }
            catch (error) {
                throw new Error(`Push SDK Error: API : notifcaiton::unsubscribe : ${error}`);
            }
        });
    }
}
exports.Notification = Notification;
//# sourceMappingURL=notification.js.map