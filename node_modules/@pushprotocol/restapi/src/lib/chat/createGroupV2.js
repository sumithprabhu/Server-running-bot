"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGroupCoreV2 = exports.createGroupV2 = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const helpers_1 = require("../helpers");
const constants_1 = require("../constants");
const helpers_2 = require("./helpers");
const CryptoJS = require("crypto-js");
const createGroupV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.createGroupCoreV2)(options, helpers_2.PGPHelper);
});
exports.createGroupV2 = createGroupV2;
const createGroupCoreV2 = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { account = null, signer = null, pgpPrivateKey = null, env = constants_1.default.ENV.PROD, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins, } = options;
    try {
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, pgpHelper);
        const convertedMembersPromise = members.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (0, helpers_2.getUserDID)(each, env);
        }));
        const convertedAdminsPromise = admins.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            return (0, helpers_2.getUserDID)(each, env);
        }));
        const convertedMembers = yield Promise.all(convertedMembersPromise);
        const convertedAdmins = yield Promise.all(convertedAdminsPromise);
        /**
         * VALIDATIONS
         */
        createGroupV2OptionsValidator(options);
        /**
         * PROFILE VERIFICATION PROOF
         */
        const profileVerificationBody = {
            groupName,
            groupDescription,
            groupImage,
            rules,
            isPublic,
            groupType,
        };
        const profileHash = CryptoJS.SHA256(JSON.stringify(profileVerificationBody)).toString();
        const profileSignature = yield pgpHelper.sign({
            message: profileHash,
            signingKey: connectedUser.privateKey,
        });
        const profileVerificationProof = `pgpv2:${profileSignature}:${connectedUser.did}`;
        /**
         * CONFIG VERIFICATION PROOF
         */
        const configVerificationBody = {
            meta,
            scheduleAt,
            scheduleEnd,
            status,
        };
        const configHash = CryptoJS.SHA256(JSON.stringify(configVerificationBody)).toString();
        const configSignature = yield pgpHelper.sign({
            message: configHash,
            signingKey: connectedUser.privateKey,
        });
        const configVerificationProof = `pgpv2:${configSignature}:${connectedUser.did}`;
        /**
         * IDEMPOTENT VERIFICATION PROOF
         */
        const idempotentVerificationBody = {
            members: convertedMembers,
            admins: convertedAdmins,
        };
        const idempotentHash = CryptoJS.SHA256(JSON.stringify(idempotentVerificationBody)).toString();
        const idempotentSignature = yield pgpHelper.sign({
            message: idempotentHash,
            signingKey: connectedUser.privateKey,
        });
        const idempotentVerificationProof = `pgpv2:${idempotentSignature}:${connectedUser.did}`;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v2/chat/groups`;
        const body = {
            groupName,
            groupDescription,
            groupImage,
            rules,
            isPublic,
            groupType,
            profileVerificationProof,
            config: {
                meta,
                scheduleAt,
                scheduleEnd,
                status,
                configVerificationProof,
            },
            members: convertedMembers,
            admins: convertedAdmins,
            idempotentVerificationProof,
        };
        return axios_1.default
            .post(apiEndpoint, body)
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            var _a, _b;
            if ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data)
                throw new Error(JSON.stringify((_b = err === null || err === void 0 ? void 0 : err.response) === null || _b === void 0 ? void 0 : _b.data));
            throw new Error(err);
        });
    }
    catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.createGroupV2.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.createGroupV2.name} -: ${err}`);
    }
});
exports.createGroupCoreV2 = createGroupCoreV2;
const createGroupV2OptionsValidator = (options) => {
    const { account = null, signer = null, pgpPrivateKey = null, groupName, groupDescription, groupImage, rules, isPublic, groupType, config: { meta, scheduleAt, scheduleEnd, status }, members, admins, } = options;
    if (!pgpPrivateKey && !signer) {
        throw new Error(`At least one from pgpPrivateKey or signer is necessary!`);
    }
    if (groupName == null || groupName.length == 0) {
        throw new Error(`groupName cannot be null or empty`);
    }
    if (groupName.length > 50) {
        throw new Error(`groupName cannot be more than 50 characters`);
    }
    if (groupDescription && groupDescription.length > 150) {
        throw new Error(`groupDescription cannot be more than 150 characters`);
    }
    for (let i = 0; i < members.length; i++) {
        if (members[i] && !(0, helpers_1.isValidETHAddress)(members[i])) {
            throw new Error(`Invalid member address!`);
        }
    }
    for (let i = 0; i < admins.length; i++) {
        if (!(0, helpers_1.isValidETHAddress)(admins[i])) {
            throw new Error(`Invalid admin address!`);
        }
    }
    (0, helpers_2.validateScheduleDates)(scheduleAt, scheduleEnd);
};
//# sourceMappingURL=createGroupV2.js.map