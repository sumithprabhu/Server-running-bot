"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateGroupMembers = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const helpers_1 = require("../helpers");
const constants_1 = require("../constants");
const helpers_2 = require("./helpers");
const CryptoJS = require("crypto-js");
const getGroupInfo_1 = require("./getGroupInfo");
const getGroupMemberStatus_1 = require("./getGroupMemberStatus");
const AES = require("../chat/helpers/aes");
const getAllGroupMembersPublicKeys_1 = require("./getAllGroupMembersPublicKeys");
const config_1 = require("../config");
const updateGroupMembers = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { chatId, upsert, remove, account = null, signer = null, env = constants_1.default.ENV.PROD, pgpPrivateKey = null, overrideSecretKeyGeneration = !config_1.ALPHA_FEATURE_CONFIG[constants_1.PACKAGE_BUILD].feature.includes(constants_1.default.ALPHA_FEATURES.SCALABILITY_V2), } = options;
    try {
        (0, helpers_2.validateGroupMemberUpdateOptions)(options);
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const connectedUser = yield (0, helpers_2.getConnectedUserV2Core)(wallet, pgpPrivateKey, env, helpers_2.PGPHelper);
        const convertedUpsertPromise = Object.entries(upsert).map(([role, userDIDs]) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const userIDs = yield Promise.all(userDIDs.map((userDID) => (0, helpers_2.getUserDID)(userDID, env)));
            return [role, userIDs];
        }));
        const convertedUpsert = Object.fromEntries(yield Promise.all(convertedUpsertPromise));
        const convertedRemove = yield Promise.all(remove.map((userDID) => (0, helpers_2.getUserDID)(userDID, env)));
        let encryptedSecret = null;
        const group = yield (0, getGroupInfo_1.getGroupInfo)({ chatId, env });
        if (!group) {
            throw new Error(`Group not found`);
        }
        if (!group.isPublic) {
            if (group.encryptedSecret || !overrideSecretKeyGeneration) {
                const { isMember } = yield (0, getGroupMemberStatus_1.getGroupMemberStatus)({
                    chatId,
                    did: connectedUser.did,
                    env,
                });
                const groupMembers = yield (0, getAllGroupMembersPublicKeys_1.getAllGroupMembersPublicKeys)({
                    chatId,
                    env,
                });
                const removeParticipantSet = new Set(convertedRemove.map((participant) => participant.toLowerCase()));
                let sameMembers = true;
                groupMembers.map((element) => {
                    if (removeParticipantSet.has(element.did.toLowerCase())) {
                        sameMembers = false;
                    }
                });
                if (!sameMembers || !isMember) {
                    const secretKey = AES.generateRandomSecret(15);
                    const publicKeys = [];
                    // This will now only take keys of non-removed members
                    groupMembers.map((element) => {
                        if (!removeParticipantSet.has(element.did.toLowerCase())) {
                            publicKeys.push(element.publicKey);
                        }
                    });
                    // This is autoJoin Case
                    if (!isMember) {
                        publicKeys.push(connectedUser.publicKey);
                    }
                    // Encrypt secret key with group members public keys
                    encryptedSecret = yield (0, helpers_2.pgpEncrypt)({
                        plainText: secretKey,
                        keys: publicKeys,
                    });
                }
            }
        }
        const bodyToBeHashed = {
            upsert: convertedUpsert,
            remove: convertedRemove,
            encryptedSecret,
        };
        const hash = CryptoJS.SHA256(JSON.stringify(bodyToBeHashed)).toString();
        const signature = yield helpers_2.PGPHelper.sign({
            message: hash,
            signingKey: connectedUser.privateKey,
        });
        const sigType = 'pgpv2';
        const deltaVerificationProof = `${sigType}:${signature}:${connectedUser.did}`;
        const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v1/chat/groups/${chatId}/members`;
        const body = {
            upsert: convertedUpsert,
            remove: convertedRemove,
            encryptedSecret,
            deltaVerificationProof,
        };
        return axios_1.default
            .put(apiEndpoint, body)
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            var _a;
            if ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data)
                throw new Error(JSON.stringify(err.response.data));
            throw new Error(err);
        });
    }
    catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.updateGroupMembers.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.updateGroupMembers.name} -: ${err}`);
    }
});
exports.updateGroupMembers = updateGroupMembers;
//# sourceMappingURL=updateGroupMembers.js.map