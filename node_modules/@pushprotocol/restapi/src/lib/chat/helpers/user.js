"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserDID = exports.getConnectedUserV2Core = exports.getConnectedUserV2 = exports.getConnectedUser = exports.createUserIfNecessary = void 0;
const tslib_1 = require("tslib");
const constants_1 = require("../../constants");
const user_1 = require("../../user");
const wallet_1 = require("./wallet");
const _1 = require(".");
const helpers_1 = require("../../helpers");
const createUserIfNecessary = (wallet, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const address = yield (0, wallet_1.getAccountAddress)(wallet);
    const connectedUser = yield (0, user_1.get)({ account: address, env });
    if (!(connectedUser === null || connectedUser === void 0 ? void 0 : connectedUser.encryptedPrivateKey)) {
        const createUserProps = {};
        if (wallet.account) {
            createUserProps.account = wallet.account;
        }
        if (wallet.signer) {
            createUserProps.signer = wallet.signer;
        }
        createUserProps.env = env;
        const createdUser = yield (0, user_1.create)(createUserProps);
        return createdUser;
    }
    else {
        return connectedUser;
    }
});
exports.createUserIfNecessary = createUserIfNecessary;
const getConnectedUser = (wallet, privateKey, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const address = yield (0, wallet_1.getAccountAddress)(wallet);
    const user = yield (0, user_1.get)({ account: address, env: env || constants_1.default.ENV.PROD });
    if (user === null || user === void 0 ? void 0 : user.encryptedPrivateKey) {
        if (privateKey) {
            return Object.assign(Object.assign({}, user), { privateKey });
        }
        else {
            throw new Error(`Decrypted pgp private key required as input`);
        }
    }
    else {
        const createUserProps = {};
        if (wallet.account) {
            createUserProps.account = wallet.account;
        }
        if (user && user.did) {
            createUserProps.account = user.did;
        }
        if (wallet.signer) {
            createUserProps.signer = wallet.signer;
        }
        createUserProps.env = env;
        const newUser = yield (0, user_1.create)(createUserProps);
        const decryptedPrivateKey = yield (0, _1.getDecryptedPrivateKey)(wallet, newUser, address);
        return Object.assign(Object.assign({}, newUser), { privateKey: decryptedPrivateKey });
    }
});
exports.getConnectedUser = getConnectedUser;
const getConnectedUserV2 = (wallet, privateKey, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return yield (0, exports.getConnectedUserV2Core)(wallet, privateKey, env, _1.PGPHelper);
});
exports.getConnectedUserV2 = getConnectedUserV2;
const getConnectedUserV2Core = (wallet, privateKey, env, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const address = yield (0, wallet_1.getAccountAddress)(wallet);
    const user = yield (0, user_1.get)({ account: address, env: env || constants_1.default.ENV.PROD });
    if (user === null || user === void 0 ? void 0 : user.encryptedPrivateKey) {
        if (privateKey) {
            return Object.assign(Object.assign({}, user), { privateKey });
        }
        else {
            console.warn("Please note that if you don't pass the pgpPrivateKey parameter, a wallet popup will appear every time the approveRequest endpoint is called. We strongly recommend passing this parameter, and it will become mandatory in future versions of the API.");
            const decryptedPrivateKey = yield (0, _1.getDecryptedPrivateKey)(wallet, user, address);
            return Object.assign(Object.assign({}, user), { privateKey: decryptedPrivateKey });
        }
    }
    else {
        const createUserProps = {};
        if (wallet.account) {
            createUserProps.account = wallet.account;
        }
        if (user && user.did) {
            createUserProps.account = user.did;
        }
        if (wallet.signer) {
            createUserProps.signer = wallet.signer;
        }
        createUserProps.env = env;
        const newUser = yield (0, user_1.createUserCore)(createUserProps, pgpHelper);
        const decryptedPrivateKey = yield (0, _1.getDecryptedPrivateKey)(wallet, newUser, address);
        return Object.assign(Object.assign({}, newUser), { privateKey: decryptedPrivateKey });
    }
});
exports.getConnectedUserV2Core = getConnectedUserV2Core;
const getUserDID = (address, env) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if ((0, helpers_1.isValidCAIP10NFTAddress)(address)) {
        if (address.split(':').length === 6)
            return address;
        const user = yield (0, user_1.get)({ account: address, env: env });
        if (user && user.did)
            return user.did;
        const epoch = Math.floor(Date.now() / 1000);
        address = `${address}:${epoch}`;
    }
    if ((0, helpers_1.isValidETHAddress)(address))
        return (0, helpers_1.walletToPCAIP10)(address);
    return address;
});
exports.getUserDID = getUserDID;
//# sourceMappingURL=user.js.map