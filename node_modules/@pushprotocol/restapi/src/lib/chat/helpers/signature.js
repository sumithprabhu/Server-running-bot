"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyProfileSignature = exports.getTypedData = exports.getTypeInformation = exports.getDomainInformation = void 0;
const tslib_1 = require("tslib");
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const viem = require("viem");
/**
 *
 * @param chainId
 * @returns
 */
const getDomainInformation = (chainId) => {
    const chatVerifyingContract = '0x0000000000000000000000000000000000000000';
    return {
        name: 'PUSH CHAT ID',
        chainId,
        verifyingContract: chatVerifyingContract,
    };
};
exports.getDomainInformation = getDomainInformation;
/**
 *
 * @param action
 * @returns
 */
const getTypeInformation = () => {
    return {
        Data: [{ name: 'data', type: 'string' }],
    };
};
exports.getTypeInformation = getTypeInformation;
/**
 *
 * @param signedData
 * @param chainId
 * @param version
 * @returns typedData for typedV4 EIP712 sig
 */
const getTypedData = (signedData, chainId, version) => {
    const message = { data: signedData };
    const typeInformation = (0, exports.getTypeInformation)();
    const domainInformation = (0, exports.getDomainInformation)(chainId);
    const primaryType = 'Data';
    let types;
    let domain = {};
    if (version === 'V1') {
        types = {
            EIP712Domain: [],
            Data: typeInformation.Data,
        };
    }
    else {
        types = {
            EIP712Domain: [
                { name: 'name', type: 'string' },
                { name: 'chainId', type: 'uint256' },
                { name: 'verifyingContract', type: 'address' },
            ],
            Data: typeInformation.Data,
        };
        domain = domainInformation;
    }
    return {
        types,
        primaryType,
        domain,
        message,
    };
};
exports.getTypedData = getTypedData;
/**
 *
 * @param signature
 * @param signedData
 * @param address
 * @param chainId
 * @returns
 */
const verifyProfileSignature = (verificationProof, signedData, address) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const SIG_TYPE_V2 = 'eip712v2';
    const SIG_TYPE_V3 = 'eip191';
    const SIG_TYPE_V4 = 'eip191v2';
    let chainId = null;
    let signature;
    const sigType = verificationProof.split(':')[0];
    if ((sigType !== SIG_TYPE_V2 &&
        sigType !== SIG_TYPE_V3 &&
        sigType !== SIG_TYPE_V4) ||
        verificationProof.split(':').length > 3) {
        return false;
    }
    if (verificationProof.split(':').length === 2) {
        signature = verificationProof.split(':')[1];
    }
    else {
        chainId = parseInt(verificationProof.split(':')[1]);
        signature = verificationProof.split(':')[2];
    }
    if (sigType === SIG_TYPE_V2) {
        try {
            // EIP712 sig validation with empty domain
            // V2 should be checked first rather than v1 otherwise validation will fail
            const typedData = (0, exports.getTypedData)(signedData, chainId, 'V2'); // For backward compatibility
            const recoveredAddress = (0, eth_sig_util_1.recoverTypedSignature)({
                data: typedData,
                signature: signature,
                version: eth_sig_util_1.SignTypedDataVersion.V4,
            });
            if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
                return true;
            }
            else
                return false;
        }
        catch (err) {
            // EIP712 sig validation with domain details
            const typedData = (0, exports.getTypedData)(signedData, chainId, 'V1'); // For backward compatibility
            const recoveredAddress = (0, eth_sig_util_1.recoverTypedSignature)({
                data: typedData,
                signature: signature,
                version: eth_sig_util_1.SignTypedDataVersion.V4,
            });
            if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
                return true;
            }
            else
                return false;
        }
    }
    else {
        // EIP191 sig validation
        try {
            // EOA Wallet
            const recoveredAddress = yield viem.recoverAddress({
                hash: viem.hashMessage(signedData),
                signature: signature,
            });
            if (recoveredAddress.toLowerCase() === address.toLowerCase()) {
                return true;
            }
            else
                return false;
        }
        catch (err) {
            return false;
            // TODO - Add support for SCW Wallet
            /**
             * @todo - Add support for SCW Wallet
             * @notice - verifyMessage does not work with EthersV6
             */
            // try {
            //   const verificationResult: boolean = await verifyMessage({
            //     signer: address.toLowerCase(),
            //     message: signedData,
            //     signature: signature,
            //     provider: ethers.getDefaultProvider(1),
            //   });
            //   return verificationResult;
            // } catch (err) {
            //   return false;
            // }
        }
    }
});
exports.verifyProfileSignature = verifyProfileSignature;
//# sourceMappingURL=signature.js.map