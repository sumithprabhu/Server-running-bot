"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.profileUpdateCore = exports.profileUpdate = void 0;
const tslib_1 = require("tslib");
const CryptoJS = require("crypto-js");
const helpers_1 = require("../chat/helpers");
const constants_1 = require("../constants");
const helpers_2 = require("../helpers");
const getUser_1 = require("./getUser");
const populateIUser_1 = require("../utils/populateIUser");
const progressHook_1 = require("../progressHook");
const axiosUtil_1 = require("../utils/axiosUtil");
/**
 * Updation of profile
 */
const profileUpdate = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return (0, exports.profileUpdateCore)(options, helpers_1.PGPHelper);
});
exports.profileUpdate = profileUpdate;
const profileUpdateCore = (options, pgpHelper) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { pgpPrivateKey, account, profile, env = constants_1.default.ENV.PROD, progressHook, } = options || {};
    try {
        if (!(0, helpers_2.isValidETHAddress)(account)) {
            throw new Error(`Invalid account!`);
        }
        const user = yield (0, getUser_1.get)({ account, env });
        if (!user || !user.did) {
            throw new Error('User not Found!');
        }
        let blockedUsersList = null;
        if (profile.blockedUsersList) {
            for (const element of profile.blockedUsersList) {
                // Check if the element is a valid CAIP-10 address
                if (!(0, helpers_2.isValidETHAddress)(element)) {
                    throw new Error('Invalid address in the blockedUsersList: ' + element);
                }
            }
            const convertedBlockedListUsersPromise = profile.blockedUsersList.map((each) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                return (0, helpers_1.getUserDID)(each, env);
            }));
            blockedUsersList = yield Promise.all(convertedBlockedListUsersPromise);
            blockedUsersList = Array.from(new Set(blockedUsersList));
        }
        const updatedProfile = {
            name: profile.name ? profile.name : user.profile.name,
            desc: profile.desc ? profile.desc : user.profile.desc,
            picture: profile.picture ? profile.picture : user.profile.picture,
            // If profile.blockedUsersList is empty no users in block list
            blockedUsersList: profile.blockedUsersList ? blockedUsersList : [],
        };
        const hash = CryptoJS.SHA256(JSON.stringify(updatedProfile)).toString();
        const signature = yield pgpHelper.sign({
            message: hash,
            signingKey: pgpPrivateKey,
        });
        const sigType = 'pgpv2';
        const verificationProof = `${sigType}:${signature}`;
        const body = Object.assign(Object.assign({}, updatedProfile), { verificationProof });
        const API_BASE_URL = (0, helpers_2.getAPIBaseUrls)(env);
        const apiEndpoint = `${API_BASE_URL}/v2/users/${user.did}/profile`;
        // Report Progress
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default['PUSH-PROFILE-UPDATE-01']);
        const response = yield (0, axiosUtil_1.axiosPut)(apiEndpoint, body);
        if (response.data)
            response.data.publicKey = yield (0, helpers_2.verifyProfileKeys)(response.data.encryptedPrivateKey, response.data.publicKey, response.data.did, response.data.wallets, response.data.verificationProof);
        // Report Progress
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(progressHook_1.default['PUSH-PROFILE-UPDATE-02']);
        return (0, populateIUser_1.populateDeprecatedUser)(response.data);
    }
    catch (err) {
        // Report Progress
        const errorProgressHook = progressHook_1.default['PUSH-ERROR-00'];
        progressHook === null || progressHook === void 0 ? void 0 : progressHook(errorProgressHook(exports.profileUpdate.name, err));
        throw Error(`[Push SDK] - API - Error - API ${exports.profileUpdate.name} -: ${err}`);
    }
});
exports.profileUpdateCore = profileUpdateCore;
//# sourceMappingURL=profile.updateUser.js.map