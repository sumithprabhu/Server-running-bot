"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoV2 = void 0;
const tslib_1 = require("tslib");
const immer_1 = require("immer");
const chat_1 = require("../chat");
const helpers_1 = require("../helpers");
const constants_1 = require("../payloads/constants");
const types_1 = require("../types");
const validatePeerInfo_1 = require("./helpers/validatePeerInfo");
/**
 * VideoV2 class
 */
class VideoV2 {
    /**
     * VideoV2 constructor
     * @param {object} params - The constructor parameters
     * @param {VideoV1} params.videoV1Instance - The VideoV1 instance
     * @param {string} params.account - The account
     * @param {string} params.decryptedPgpPvtKey - The decrypted PGP private key
     * @param {ENV} params.env - The environment
     */
    constructor({ videoV1Instance, account, decryptedPgpPvtKey, env, peerInfos }) {
        this.videoInstance = videoV1Instance;
        this.account = account;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.env = env;
        this.peerInfos = peerInfos;
    }
    /**
     * Request a video call
     * @param {string[]} recipients - The recipients of the video call
     * @param {object} options - The options for the video call
     * @param {object} options.rules - The rules for the video call
     * @param {object} options.rules.access - The access rules for the video call
     * @param {string} options.rules.access.type - The type of the video call
     * @param {object} options.rules.access.data - The data for the video call
     * @param {string} options.rules.access.data.chatId - The chat ID for the video call
     */
    request(recipients, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { rules } = options || {};
            for (const recipient of recipients) {
                if (!(0, helpers_1.isValidETHAddress)(recipient)) {
                    throw new Error('Invalid recipient address found');
                }
            }
            if (recipients.length === 0) {
                throw new Error('Alteast one recipient address is required for a video call');
            }
            if (recipients.length > 1 &&
                (rules === null || rules === void 0 ? void 0 : rules.access.type) === constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT &&
                !rules.access.data.chatId) {
                throw new Error('For multiple recipient addresses, chatId is required for a video call');
            }
            // If chatId is not passed, find a w2w chat between the addresses and use the chatId from there
            let retrievedChatId = '';
            if (!(rules === null || rules === void 0 ? void 0 : rules.access.data.chatId)) {
                let page = 1;
                const limit = 30;
                while (!retrievedChatId) {
                    const response = yield (0, chat_1.chats)({
                        account: this.account,
                        toDecrypt: true,
                        pgpPrivateKey: this.decryptedPgpPvtKey,
                        env: this.env,
                        page,
                        limit,
                    });
                    if (response.length === 0)
                        break;
                    response.forEach((chat) => {
                        if (chat.did === (0, helpers_1.walletToPCAIP10)(recipients[0]) && chat.chatId) {
                            retrievedChatId = chat.chatId;
                        }
                    });
                    page++;
                }
                if (!retrievedChatId) {
                    throw new Error(`ChatId not found between local user (${this.account}) and recipient (${recipients[0]}).`);
                }
            }
            this.videoInstance.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                    var _a;
                    draft.local.address = this.account;
                    draft.incoming = recipients.map((recipient) => ({
                        address: (0, helpers_1.pCAIP10ToWallet)(recipient),
                        status: types_1.VideoCallStatus.INITIALIZED,
                    }));
                    draft.meta.chatId = (_a = rules === null || rules === void 0 ? void 0 : rules.access.data.chatId) !== null && _a !== void 0 ? _a : retrievedChatId;
                });
            });
            yield this.videoInstance.request({
                senderAddress: (0, helpers_1.pCAIP10ToWallet)(this.account),
                recipientAddress: recipients.map((recipient) => (0, helpers_1.pCAIP10ToWallet)(recipient)),
                rules: rules !== null && rules !== void 0 ? rules : {
                    access: {
                        type: constants_1.VIDEO_NOTIFICATION_ACCESS_TYPE.PUSH_CHAT,
                        data: {
                            chatId: retrievedChatId,
                        },
                    },
                },
            });
        });
    }
    /**
     * Approve a video call
     * @param {string} [address] - The address of the peer from which the video call is to be approved
     */
    approve(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!address) {
                const peerInfoAddresses = Object.keys(this.peerInfos);
                if (peerInfoAddresses.length !== 1) {
                    throw new Error('Either no request exists or more than one request found. Please pass an address.');
                }
                address = peerInfoAddresses[0];
            }
            const peerInfo = this.peerInfos[(0, helpers_1.walletToPCAIP10)(address)];
            (0, validatePeerInfo_1.validatePeerInfo)(peerInfo);
            yield this.videoInstance.acceptRequest({
                senderAddress: (0, helpers_1.pCAIP10ToWallet)(this.account),
                recipientAddress: (0, helpers_1.pCAIP10ToWallet)(address),
                signalData: peerInfo.signal,
                rules: peerInfo.meta.rules,
            });
        });
    }
    /**
     * Deny a video call
     * @param {string} [address] - The address of the peer from which the video call is to be denied
     */
    deny(address) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!address) {
                const peerInfoAddresses = Object.keys(this.peerInfos);
                if (peerInfoAddresses.length !== 1) {
                    throw new Error('Either no request exists or more than one request found. Please pass an address.');
                }
                address = peerInfoAddresses[0];
            }
            const peerInfo = this.peerInfos[(0, helpers_1.walletToPCAIP10)(address)];
            (0, validatePeerInfo_1.validatePeerInfo)(peerInfo);
            yield this.videoInstance.disconnect({
                peerAddress: (0, helpers_1.pCAIP10ToWallet)(address),
            });
        });
    }
    /**
     * Disconnect from a video call
     */
    disconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.videoInstance.disconnect();
        });
    }
    /**
     * Enable or disable config properties (video, audio)
     * @param {object} params - The parameters
     * @param {boolean} params.video - The video state
     * @param {boolean} params.audio - The audio state
     */
    config({ video, audio }) {
        if (typeof video === 'boolean') {
            this.videoInstance.enableVideo({ state: video });
        }
        if (typeof audio === 'boolean') {
            this.videoInstance.enableAudio({ state: audio });
        }
    }
}
exports.VideoV2 = VideoV2;
//# sourceMappingURL=VideoV2.js.map