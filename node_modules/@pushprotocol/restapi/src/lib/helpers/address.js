"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pCAIP10ToWallet = exports.walletToPCAIP10 = exports.getCAIPWithChainId = exports.getCAIPAddress = exports.getFallbackETHCAIPAddress = exports.getCAIPDetails = exports.validateCAIP = exports.isValidCAIP10NFTAddress = exports.isValidNFTCAIP10Address = exports.isValidETHAddress = void 0;
const tslib_1 = require("tslib");
const viem = require("viem");
const constants_1 = require("../constants");
const helpers_1 = require("../chat/helpers");
function isValidETHAddress(address) {
    if ((0, exports.isValidCAIP10NFTAddress)(address))
        return true;
    if (address.includes('eip155:')) {
        const splittedAddress = address.split(':');
        if (splittedAddress.length === 3) {
            return viem.isAddress(splittedAddress[2]);
        }
        if (splittedAddress.length === 2)
            return viem.isAddress(splittedAddress[1]);
    }
    return viem.isAddress(address);
}
exports.isValidETHAddress = isValidETHAddress;
function isValidNFTCAIP10Address(realCAIP10) {
    const walletComponent = realCAIP10.split(':');
    if (isNaN(Number(walletComponent[1])))
        return false;
    return (walletComponent.length === 3 && walletComponent[0] === 'eip155' && viem.isAddress(walletComponent[2]));
}
exports.isValidNFTCAIP10Address = isValidNFTCAIP10Address;
/**
 *
 * @param wallet nft:eip155:nftChainId:nftContractAddress:nftTokenId
 * @returns
 */
const isValidCAIP10NFTAddress = (wallet) => {
    try {
        const walletComponent = wallet.split(':');
        return ((walletComponent.length === 5 || walletComponent.length === 6) &&
            walletComponent[0].toLowerCase() === 'nft' &&
            !isNaN(Number(walletComponent[4])) &&
            Number(walletComponent[4]) > 0 &&
            !isNaN(Number(walletComponent[2])) &&
            Number(walletComponent[2]) > 0 &&
            viem.isAddress(walletComponent[3]) &&
            walletComponent[1] === 'eip155');
    }
    catch (err) {
        return false;
    }
};
exports.isValidCAIP10NFTAddress = isValidCAIP10NFTAddress;
const AddressValidators = {
    // Ethereum
    'eip155': ({ address }) => {
        return isValidETHAddress(address);
    }
    // Add other chains here
};
function validateCAIP(addressInCAIP) {
    const [blockchain, networkId, address] = addressInCAIP.split(':');
    if (!blockchain)
        return false;
    if (!networkId)
        return false;
    if (!address)
        return false;
    if ((0, exports.isValidCAIP10NFTAddress)(addressInCAIP))
        return true;
    const validatorFn = AddressValidators[blockchain];
    return validatorFn({ address });
}
exports.validateCAIP = validateCAIP;
function getCAIPDetails(addressInCAIP) {
    if (validateCAIP(addressInCAIP)) {
        const [blockchain, networkId, address] = addressInCAIP.split(':');
        return {
            blockchain,
            networkId,
            address
        };
    }
    return null;
}
exports.getCAIPDetails = getCAIPDetails;
function getFallbackETHCAIPAddress(env, address) {
    let chainId = 1; // by default PROD
    if (env === constants_1.default.ENV.DEV || env === constants_1.default.ENV.STAGING || env === constants_1.default.ENV.LOCAL) {
        chainId = 11155111;
    }
    return `eip155:${chainId}:${address}`;
}
exports.getFallbackETHCAIPAddress = getFallbackETHCAIPAddress;
/**
 * This helper
 *  checks if a VALID CAIP
 *    return the CAIP
 *  else
 *    check if valid ETH
 *      return a CAIP representation of that address (EIP155 + env)
 *    else
 *      throw error!
 */
function getCAIPAddress(env, address, msg) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if ((0, exports.isValidCAIP10NFTAddress)(address)) {
            return yield (0, helpers_1.getUserDID)(address, env);
        }
        if (validateCAIP(address)) {
            return address;
        }
        else {
            if (isValidETHAddress(address)) {
                return getFallbackETHCAIPAddress(env, address);
            }
            else {
                throw Error(`Invalid Address! ${msg} \n Address: ${address}`);
            }
        }
    });
}
exports.getCAIPAddress = getCAIPAddress;
const getCAIPWithChainId = (address, chainId, msg) => {
    if (isValidETHAddress(address)) {
        if (!address.includes('eip155:'))
            return `eip155:${chainId}:${address}`;
        else
            return address;
    }
    else {
        throw Error(`Invalid Address! ${msg} \n Address: ${address}`);
    }
};
exports.getCAIPWithChainId = getCAIPWithChainId;
// P = Partial CAIP
const walletToPCAIP10 = (account) => {
    if ((0, exports.isValidCAIP10NFTAddress)(account) || account.includes('eip155:')) {
        return account;
    }
    return 'eip155:' + account;
};
exports.walletToPCAIP10 = walletToPCAIP10;
const pCAIP10ToWallet = (wallet) => {
    if ((0, exports.isValidCAIP10NFTAddress)(wallet))
        return wallet;
    wallet = wallet.replace('eip155:', '');
    return wallet;
};
exports.pCAIP10ToWallet = pCAIP10ToWallet;
//# sourceMappingURL=address.js.map