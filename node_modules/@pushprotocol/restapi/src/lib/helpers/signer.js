"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = void 0;
const tslib_1 = require("tslib");
class Signer {
    constructor(signer) {
        this.signer = signer;
    }
    /**
     * Determine if the signer is a Viem signer
     */
    isViemSigner(signer) {
        return (typeof signer.signTypedData === 'function' &&
            typeof signer.getChainId === 'function' &&
            signer.signMessage.length === 1 && // Checking if the function takes one argument
            signer.signTypedData.length === 1 // Checking if the function takes one argument
        );
    }
    signMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if ('signMessage' in this.signer &&
                typeof this.signer.signMessage === 'function') {
                if (this.isViemSigner(this.signer)) {
                    // Viem signer requires additional arguments
                    return this.signer.signMessage({
                        message,
                        account: this.signer.account,
                    });
                }
                else {
                    // EthersV5 and EthersV6
                    return this.signer.signMessage(message);
                }
            }
            else {
                throw new Error('Signer does not support signMessage');
            }
        });
    }
    signTypedData(domain, types, value, primaryType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isViemSigner(this.signer)) {
                // Call Viem's signTypedData with its specific structure
                return this.signer.signTypedData({
                    domain: domain,
                    types: types,
                    primaryType: primaryType,
                    message: value,
                    account: this.signer.account,
                });
            }
            else if ('_signTypedData' in this.signer) {
                // ethersV5 signer uses _signTypedData
                return this.signer._signTypedData(domain, types, value);
            }
            else if ('signTypedData' in this.signer) {
                // ethersV6 signer uses signTypedData
                return this.signer.signTypedData(domain, types, value);
            }
            else {
                throw new Error('Signer does not support signTypedData');
            }
        });
    }
    getAddress() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isViemSigner(this.signer)) {
                return (_a = this.signer.account['address']) !== null && _a !== void 0 ? _a : '';
            }
            else {
                return yield this.signer.getAddress();
            }
        });
    }
    getChainId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.isViemSigner(this.signer)) {
                // Viem signer has a direct method for getChainId
                return this.signer.getChainId();
            }
            else if ('provider' in this.signer && this.signer.provider) {
                // EthersV5 and EthersV6
                const network = yield this.signer.provider.getNetwork();
                return Number(network.chainId);
            }
            else {
                return 1; // Return default chainId
            }
        });
    }
}
exports.Signer = Signer;
//# sourceMappingURL=signer.js.map