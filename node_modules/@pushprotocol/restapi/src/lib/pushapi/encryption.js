"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encryption = void 0;
const tslib_1 = require("tslib");
const PUSH_USER = require("../user");
const PushAPI_1 = require("./PushAPI");
const user_1 = require("./user");
class Encryption {
    constructor(account, env, decryptedPgpPvtKey, pgpPublicKey, signer, progressHook) {
        this.account = account;
        this.env = env;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.pgpPublicKey = pgpPublicKey;
        this.signer = signer;
        this.progressHook = progressHook;
        this.userInstance = new user_1.User(this.account, this.env);
    }
    info() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const userInfo = yield this.userInstance.info();
            let decryptedPassword;
            if (this.signer) {
                decryptedPassword = yield PUSH_USER.decryptAuth({
                    account: this.account,
                    env: this.env,
                    signer: this.signer,
                    progressHook: this.progressHook,
                    additionalMeta: {
                        NFTPGP_V1: {
                            encryptedPassword: JSON.stringify(JSON.parse(userInfo.encryptedPrivateKey).encryptedPassword),
                        },
                    },
                });
            }
            return Object.assign({ decryptedPgpPrivateKey: this.decryptedPgpPvtKey, pgpPublicKey: this.pgpPublicKey }, (decryptedPassword !== undefined && decryptedPassword !== null
                ? { decryptedPassword: decryptedPassword }
                : {}));
        });
    }
    update(updatedEncryptionType, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signer) {
                throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            if (!this.decryptedPgpPvtKey || !this.pgpPublicKey) {
                throw new Error(PushAPI_1.PushAPI.ensureSignerMessage());
            }
            return yield PUSH_USER.auth.update({
                account: this.account,
                pgpEncryptionVersion: updatedEncryptionType,
                additionalMeta: options === null || options === void 0 ? void 0 : options.versionMeta,
                progressHook: this.progressHook,
                signer: this.signer,
                env: this.env,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                pgpPublicKey: this.pgpPublicKey,
            });
        });
    }
}
exports.Encryption = Encryption;
//# sourceMappingURL=encryption.js.map