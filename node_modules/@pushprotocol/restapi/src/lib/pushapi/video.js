"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = void 0;
const tslib_1 = require("tslib");
const constantsV2_1 = require("../constantsV2");
const types_1 = require("../types");
const helpers_1 = require("../helpers");
const Video_1 = require("../video/Video");
const VideoV2_1 = require("../video/VideoV2");
const immer_1 = require("immer");
const mediaToggle_1 = require("../video/helpers/mediaToggle");
class Video {
    constructor(account, env, decryptedPgpPvtKey, signer) {
        this.account = account;
        this.env = env;
        this.decryptedPgpPvtKey = decryptedPgpPvtKey;
        this.signer = signer;
        // peerInfo objects from the incoming video call requests
        this.peerInfos = {};
    }
    initialize(onChange, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { stream, config, media } = options;
            if (!this.signer) {
                throw new Error('Signer is required for push video');
            }
            if (!this.decryptedPgpPvtKey) {
                throw new Error('PushSDK was initialized in readonly mode. Video functionality is not available.');
            }
            const chainId = yield new helpers_1.Signer(this.signer).getChainId();
            if (!chainId) {
                throw new Error('Chain Id not retrievable from signer');
            }
            // Initialize the video instance with the provided options
            const videoV1Instance = new Video_1.Video({
                signer: this.signer,
                chainId,
                pgpPrivateKey: this.decryptedPgpPvtKey,
                env: this.env,
                setData: onChange,
            });
            // Create the media stream with the provided options
            yield videoV1Instance.create(Object.assign(Object.assign(Object.assign({}, (media && {
                stream: media,
            })), ((config === null || config === void 0 ? void 0 : config.audio) && {
                audio: config.audio,
            })), ((config === null || config === void 0 ? void 0 : config.video) && {
                video: config.video,
            })));
            // Setup video event handlers
            stream.on(constantsV2_1.default.STREAM.VIDEO, (data) => {
                const { address, signal, meta: { rules }, } = data.peerInfo;
                const chatId = rules.access.data.chatId;
                // If the event is RequestVideo, update the video call 'data' state with the incoming call data
                if (data.event === constantsV2_1.default.VIDEO.EVENT.REQUEST) {
                    this.peerInfos[(0, helpers_1.walletToPCAIP10)(data.peerInfo.address)] = data.peerInfo;
                    videoV1Instance.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.local.address = this.account;
                            draft.incoming[0].address = address;
                            draft.incoming[0].status = types_1.VideoCallStatus.RECEIVED;
                            draft.meta.chatId = chatId;
                            draft.meta.initiator.address = address;
                            draft.meta.initiator.signal = signal;
                        });
                    });
                }
                // Check if the chatId from the incoming video event matches the chatId of the current video instance
                if (chatId && chatId === videoV1Instance.data.meta.chatId) {
                    // If the event is DenyVideo, destroy the local stream & reset the video call data
                    if (data.event === constantsV2_1.default.VIDEO.EVENT.DENY) {
                        // destroy the local stream
                        if (videoV1Instance.data.local.stream) {
                            (0, mediaToggle_1.endStream)(videoV1Instance.data.local.stream);
                        }
                        videoV1Instance.setData(() => Video_1.initVideoCallData);
                    }
                    // If the event is ApproveVideo or RetryApproveVideo, connect to the video
                    if (data.event === constantsV2_1.default.VIDEO.EVENT.APPROVE ||
                        data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_APPROVE) {
                        videoV1Instance.connect({ peerAddress: address, signalData: signal });
                    }
                    // If the event is RetryRequestVideo and the current instance is the initiator, send a request
                    if (data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_REQUEST &&
                        videoV1Instance.isInitiator()) {
                        videoV1Instance.request({
                            senderAddress: this.account,
                            recipientAddress: address,
                            rules,
                            retry: true,
                        });
                    }
                    // If the event is RetryRequestVideo and the current instance is not the initiator, accept the request
                    if (data.event === constantsV2_1.default.VIDEO.EVENT.RETRY_REQUEST &&
                        !videoV1Instance.isInitiator()) {
                        videoV1Instance.acceptRequest({
                            signalData: signal,
                            senderAddress: this.account,
                            recipientAddress: address,
                            rules,
                            retry: true,
                        });
                    }
                }
            });
            // Return an instance of the video v2 class
            return new VideoV2_1.VideoV2({
                videoV1Instance,
                account: this.account,
                decryptedPgpPvtKey: this.decryptedPgpPvtKey,
                env: this.env,
                peerInfos: this.peerInfos
            });
        });
    }
}
exports.Video = Video;
//# sourceMappingURL=video.js.map