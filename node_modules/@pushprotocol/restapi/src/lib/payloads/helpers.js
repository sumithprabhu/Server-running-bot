"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCAIPFormat = exports.getSource = exports.getPayloadIdentity = exports.getVerificationProof = exports.getRecipientFieldForAPIPayload = exports.getRecipients = exports.getPayloadForAPIInput = exports.getUUID = void 0;
const tslib_1 = require("tslib");
const uuid_1 = require("uuid");
const helpers_1 = require("../helpers");
const CryptoJS = require("crypto-js");
const constants_1 = require("./constants");
const helpers_2 = require("../chat/helpers");
function getUUID() {
    return (0, uuid_1.v4)();
}
exports.getUUID = getUUID;
/**
 * This function will map the Input options passed to the SDK to the "payload" structure
 * needed by the API input
 *
 * We need notificationPayload only for identityType
 *  - DIRECT_PAYLOAD
 *  - MINIMAL
 */
function getPayloadForAPIInput(inputOptions, recipients) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
    if ((inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) && (inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload)) {
        return {
            notification: {
                title: (_a = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) === null || _a === void 0 ? void 0 : _a.title,
                body: (_b = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.notification) === null || _b === void 0 ? void 0 : _b.body,
            },
            data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ acta: ((_c = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _c === void 0 ? void 0 : _c.cta) || '', aimg: ((_d = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _d === void 0 ? void 0 : _d.img) || '', amsg: ((_e = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _e === void 0 ? void 0 : _e.body) || '', asub: ((_f = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _f === void 0 ? void 0 : _f.title) || '', type: ((_g = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.type) === null || _g === void 0 ? void 0 : _g.toString()) || '' }, ((inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.expiry) && { etime: inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.expiry })), (((_h = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _h === void 0 ? void 0 : _h.etime) && {
                etime: (_j = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _j === void 0 ? void 0 : _j.etime,
            })), ((inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.hidden) && { hidden: inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.hidden })), (((_k = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _k === void 0 ? void 0 : _k.hidden) && {
                hidden: (_l = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _l === void 0 ? void 0 : _l.hidden,
            })), (((_m = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _m === void 0 ? void 0 : _m.silent) && {
                silent: (_o = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _o === void 0 ? void 0 : _o.silent,
            })), (((_p = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _p === void 0 ? void 0 : _p.sectype) && {
                sectype: (_q = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _q === void 0 ? void 0 : _q.sectype,
            })), (((_r = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _r === void 0 ? void 0 : _r.metadata) && {
                metadata: (_s = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _s === void 0 ? void 0 : _s.metadata,
            })), (((_t = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _t === void 0 ? void 0 : _t.additionalMeta) && {
                additionalMeta: (_u = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _u === void 0 ? void 0 : _u.additionalMeta,
            })), (((_v = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _v === void 0 ? void 0 : _v.index) && {
                index: (_w = inputOptions === null || inputOptions === void 0 ? void 0 : inputOptions.payload) === null || _w === void 0 ? void 0 : _w.index,
            })),
            recipients: recipients,
        };
    }
    return null;
}
exports.getPayloadForAPIInput = getPayloadForAPIInput;
/**
 * This function returns the recipient format accepted by the API for different notification types
 */
function getRecipients({ env, notificationType, channel, recipients, secretType, }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let addressInCAIP = '';
        if (secretType) {
            let secret = '';
            // return '';
            /**
             * Currently SECRET FLOW is yet to be finalized on the backend, so will revisit this later.
             * But in secret flow we basically generate secret for the address
             * and send it in { 0xtarget: secret_generated_for_0xtarget } format for all
             */
            if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED) {
                if (typeof recipients === 'string') {
                    addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, recipients, 'Recipient');
                    secret = ''; // do secret stuff // TODO
                    return {
                        [addressInCAIP]: secret,
                    };
                }
            }
            else if (notificationType === constants_1.NOTIFICATION_TYPE.SUBSET) {
                if (Array.isArray(recipients)) {
                    const recipientObject = recipients.reduce((_recipients, _rAddress) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, _rAddress, 'Recipient');
                        secret = ''; // do secret stuff // TODO
                        return Object.assign(Object.assign({}, _recipients), { [addressInCAIP]: secret });
                    }), {});
                    return recipientObject;
                }
            }
        }
        else {
            /**
             * NON-SECRET FLOW
             */
            if (notificationType === constants_1.NOTIFICATION_TYPE.BROADCAST) {
                return yield (0, helpers_1.getCAIPAddress)(env, channel, 'Recipient');
            }
            else if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED) {
                if (typeof recipients === 'string') {
                    return yield (0, helpers_1.getCAIPAddress)(env, recipients, 'Recipient');
                }
            }
            else if (notificationType === constants_1.NOTIFICATION_TYPE.SUBSET) {
                if (Array.isArray(recipients)) {
                    if (Array.isArray(recipients)) {
                        const recipientObject = {};
                        recipients.map((_rAddress) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            addressInCAIP = yield (0, helpers_1.getCAIPAddress)(env, _rAddress, 'Recipient');
                            recipientObject[addressInCAIP] = null;
                        }));
                        return recipientObject;
                    }
                }
            }
        }
        return recipients;
    });
}
exports.getRecipients = getRecipients;
function getRecipientFieldForAPIPayload({ env, notificationType, recipients, channel, }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (notificationType === constants_1.NOTIFICATION_TYPE.TARGETTED &&
            typeof recipients === 'string') {
            return yield (0, helpers_1.getCAIPAddress)(env, recipients, 'Recipient');
        }
        return yield (0, helpers_1.getCAIPAddress)(env, channel, 'Recipient');
    });
}
exports.getRecipientFieldForAPIPayload = getRecipientFieldForAPIPayload;
function getVerificationProof({ senderType, signer, chainId, notificationType, identityType, verifyingContract, payload, ipfsHash, graph = {}, uuid, chatId, wallet, pgpPrivateKey, env, rules }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let message = null;
        let verificationProof = null;
        switch (identityType) {
            case constants_1.IDENTITY_TYPE.MINIMAL: {
                message = {
                    data: `${identityType}+${notificationType}+${payload.notification.title}+${payload.notification.body}`,
                };
                break;
            }
            case constants_1.IDENTITY_TYPE.IPFS: {
                message = {
                    data: `1+${ipfsHash}`,
                };
                break;
            }
            case constants_1.IDENTITY_TYPE.DIRECT_PAYLOAD: {
                const payloadJSON = JSON.stringify(payload);
                message = {
                    data: `2+${payloadJSON}`,
                };
                break;
            }
            case constants_1.IDENTITY_TYPE.SUBGRAPH: {
                message = {
                    data: `3+graph:${graph === null || graph === void 0 ? void 0 : graph.id}+${graph === null || graph === void 0 ? void 0 : graph.counter}`,
                };
                break;
            }
            default: {
                throw new Error('Invalid IdentityType');
            }
        }
        switch (senderType) {
            case 0: {
                const type = {
                    Data: [{ name: 'data', type: 'string' }],
                };
                const domain = {
                    name: 'EPNS COMM V1',
                    chainId: chainId,
                    verifyingContract: verifyingContract,
                };
                const pushSigner = new helpers_1.Signer(signer);
                const signature = yield pushSigner.signTypedData(domain, type, message, 'Data');
                verificationProof = `eip712v2:${signature}::uid::${uuid}`;
                break;
            }
            case 1: {
                const hash = CryptoJS.SHA256(JSON.stringify(message)).toString();
                const signature = yield (0, helpers_2.sign)({
                    message: hash,
                    signingKey: pgpPrivateKey,
                });
                verificationProof = `pgpv2:${signature}:meta:${chatId}::uid::${uuid}`;
                break;
            }
            default: {
                throw new Error('Invalid SenderType');
            }
        }
        return verificationProof;
    });
}
exports.getVerificationProof = getVerificationProof;
function getPayloadIdentity({ identityType, payload, notificationType, ipfsHash, graph = {}, }) {
    if (identityType === constants_1.IDENTITY_TYPE.MINIMAL) {
        return `0+${notificationType}+${payload.notification.title}+${payload.notification.body}`;
    }
    else if (identityType === constants_1.IDENTITY_TYPE.IPFS) {
        return `1+${ipfsHash}`;
    }
    else if (identityType === constants_1.IDENTITY_TYPE.DIRECT_PAYLOAD) {
        const payloadJSON = JSON.stringify(payload);
        return `2+${payloadJSON}`;
    }
    else if (identityType === constants_1.IDENTITY_TYPE.SUBGRAPH) {
        return `3+graph:${graph === null || graph === void 0 ? void 0 : graph.id}+${graph === null || graph === void 0 ? void 0 : graph.counter}`;
    }
    return null;
}
exports.getPayloadIdentity = getPayloadIdentity;
function getSource(chainId, identityType, senderType) {
    if (senderType === 1) {
        return constants_1.SOURCE_TYPES.PUSH_VIDEO;
    }
    if (identityType === constants_1.IDENTITY_TYPE.SUBGRAPH) {
        return constants_1.SOURCE_TYPES.THE_GRAPH;
    }
    return constants_1.CHAIN_ID_TO_SOURCE[chainId];
}
exports.getSource = getSource;
function getCAIPFormat(chainId, address) {
    // EVM based chains
    if ([1, 11155111, 42, 137, 80001, 56, 97, 10, 420, 1442, 1101, 421613, 42161, 122, 123].includes(chainId)) {
        return `eip155:${chainId}:${address}`;
    }
    return address;
    // TODO: add support for other non-EVM based chains
}
exports.getCAIPFormat = getCAIPFormat;
//# sourceMappingURL=helpers.js.map