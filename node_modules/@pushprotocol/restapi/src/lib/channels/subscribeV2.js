"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeV2 = void 0;
const tslib_1 = require("tslib");
const helpers_1 = require("../helpers");
const signature_helpers_1 = require("./signature.helpers");
const constants_1 = require("../constants");
const axiosUtil_1 = require("../utils/axiosUtil");
const subscribeV2 = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const { signer, channelAddress, userAddress, settings = undefined, verifyingContractAddress, env = constants_1.default.ENV.PROD, onSuccess, onError, } = options || {};
    try {
        const _channelAddress = yield (0, helpers_1.getCAIPAddress)(env, channelAddress, 'Channel');
        const channelCAIPDetails = (0, helpers_1.getCAIPDetails)(_channelAddress);
        if (!channelCAIPDetails)
            throw Error('Invalid Channel CAIP!');
        const chainId = parseInt(channelCAIPDetails.networkId, 10);
        const _userAddress = yield (0, helpers_1.getCAIPAddress)(env, userAddress, 'User');
        const userCAIPDetails = (0, helpers_1.getCAIPDetails)(_userAddress);
        if (!userCAIPDetails)
            throw Error('Invalid User CAIP!');
        const { API_BASE_URL, EPNS_COMMUNICATOR_CONTRACT } = (0, helpers_1.getConfig)(env, channelCAIPDetails);
        const requestUrl = `${API_BASE_URL}/v1/channels/${_channelAddress}/subscribe`;
        // get domain information
        const domainInformation = (0, signature_helpers_1.getDomainInformation)(chainId, verifyingContractAddress || EPNS_COMMUNICATOR_CONTRACT);
        // get type information
        const typeInformation = (0, signature_helpers_1.getTypeInformationV2)();
        // get message
        const messageInformation = {
            data: (0, signature_helpers_1.getSubscriptionMessageV2)(channelCAIPDetails.address, userCAIPDetails.address, 'Subscribe', settings),
        };
        // sign a message using EIP712
        const pushSigner = new helpers_1.Signer(signer);
        const signature = yield pushSigner.signTypedData(domainInformation, typeInformation, messageInformation, 'Data');
        const verificationProof = signature; // might change
        const body = {
            verificationProof: `eip712v2:${verificationProof}`,
            message: messageInformation.data,
        };
        const res = yield (0, axiosUtil_1.axiosPost)(requestUrl, body);
        if (typeof onSuccess === 'function')
            onSuccess();
        return { status: res.status, message: 'successfully opted into channel' };
    }
    catch (err) {
        if (typeof onError === 'function')
            onError(err);
        return {
            status: (_b = (_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : '',
            message: err instanceof Error ? err.message : JSON.stringify(err),
        };
    }
});
exports.subscribeV2 = subscribeV2;
//# sourceMappingURL=subscribeV2.js.map