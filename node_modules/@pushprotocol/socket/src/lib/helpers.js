"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walletToPCAIP10 = exports.getCAIPAddress = exports.getFallbackETHCAIPAddress = exports.validateCAIP = exports.isValidCAIP10NFTAddress = exports.isValidETHAddress = void 0;
// import * as ethers from 'ethers';
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
function isValidETHAddress(address) {
    return ethers_1.ethers.utils.isAddress(address);
}
exports.isValidETHAddress = isValidETHAddress;
const AddressValidators = {
    // Ethereum
    eip155: ({ address }) => {
        return isValidETHAddress(address);
    },
    // Add other chains here
};
const isValidCAIP10NFTAddress = (wallet) => {
    try {
        const walletComponent = wallet.split(':');
        return ((walletComponent.length === 5 || walletComponent.length === 6) &&
            walletComponent[0].toLowerCase() === 'nft' &&
            !isNaN(Number(walletComponent[4])) &&
            Number(walletComponent[4]) > 0 &&
            !isNaN(Number(walletComponent[2])) &&
            Number(walletComponent[2]) > 0 &&
            ethers_1.ethers.utils.isAddress(walletComponent[3]) &&
            walletComponent[1] === 'eip155');
    }
    catch (err) {
        return false;
    }
};
exports.isValidCAIP10NFTAddress = isValidCAIP10NFTAddress;
function validateCAIP(addressInCAIP) {
    const [blockchain, networkId, address] = addressInCAIP.split(':');
    if (!blockchain)
        return false;
    if (!networkId)
        return false;
    if (!address)
        return false;
    if ((0, exports.isValidCAIP10NFTAddress)(addressInCAIP))
        return true;
    const validatorFn = AddressValidators[blockchain];
    return validatorFn({ address });
}
exports.validateCAIP = validateCAIP;
function getFallbackETHCAIPAddress(env, address) {
    let chainId; // by default PROD
    switch (env) {
        case constants_1.ENV.PROD:
            chainId = constants_1.DEFAULT_CHAINS.PROD;
            break;
        case constants_1.ENV.STAGING:
            chainId = constants_1.DEFAULT_CHAINS.STAGING;
            break;
        case constants_1.ENV.DEV:
            chainId = constants_1.DEFAULT_CHAINS.DEV;
            break;
        case constants_1.ENV.LOCAL:
            chainId = constants_1.DEFAULT_CHAINS.LOCAL;
            break;
        default:
            chainId = constants_1.DEFAULT_CHAINS.PROD;
    }
    return `eip155:${chainId}:${address}`;
}
exports.getFallbackETHCAIPAddress = getFallbackETHCAIPAddress;
/**
 * This helper
 *  checks if a VALID CAIP
 *    return the CAIP
 *  else
 *    check if valid ETH
 *      return a CAIP representation of that address (EIP155 + env)
 *    else
 *      throw error!
 */
function getCAIPAddress(env, address, msg) {
    if (validateCAIP(address)) {
        return address;
    }
    else {
        if (isValidETHAddress(address)) {
            return getFallbackETHCAIPAddress(env, address);
        }
        else {
            throw Error(`Invalid Address! ${msg}`);
        }
    }
}
exports.getCAIPAddress = getCAIPAddress;
const walletToPCAIP10 = (account) => {
    if (account.includes('eip155:')) {
        return account;
    }
    return 'eip155:' + account;
};
exports.walletToPCAIP10 = walletToPCAIP10;
//# sourceMappingURL=helpers.js.map