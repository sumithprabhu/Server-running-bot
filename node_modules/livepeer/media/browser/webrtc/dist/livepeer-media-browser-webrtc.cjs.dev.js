'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var asyncToGenerator = require('../../../../dist/asyncToGenerator-83313f82.cjs.dev.js');
var createForOfIteratorHelper = require('../../../../dist/createForOfIteratorHelper-1d3e6c89.cjs.dev.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.array.map.js');
require('core-js/modules/es.string.trim.js');
require('core-js/modules/es.string.starts-with.js');
require('core-js/modules/es.array.slice.js');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.string.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/web.url.js');
require('core-js/modules/web.url-search-params.js');
require('core-js/modules/es.regexp.to-string.js');
require('core-js/modules/es.promise.js');
var core = require('@livepeer/core');
var fetch = require('cross-fetch');
var utils = require('../../../../dist/utils-abbe2363.cjs.dev.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.array.includes.js');
require('core-js/modules/es.string.includes.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fetch__default = /*#__PURE__*/_interopDefault(fetch);

/**
 * Checks if WebRTC is supported.
 */
var isWebRTCSupported = function isWebRTCSupported() {
  var _window, _window2, _window3, _navigator, _navigator2, _navigator2$mediaDevi, _navigator3, _navigator4, _navigator5, _window4, _window5, _window6;
  if (!utils.isClient()) {
    return false;
  }
  var hasRTCPeerConnection = !!((_window = window) !== null && _window !== void 0 && _window.RTCPeerConnection || (_window2 = window) !== null && _window2 !== void 0 && _window2.webkitRTCPeerConnection || (_window3 = window) !== null && _window3 !== void 0 && _window3.mozRTCPeerConnection);
  var hasGetUserMedia = !!((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.getUserMedia || (_navigator2 = navigator) !== null && _navigator2 !== void 0 && (_navigator2$mediaDevi = _navigator2.mediaDevices) !== null && _navigator2$mediaDevi !== void 0 && _navigator2$mediaDevi.getUserMedia || (_navigator3 = navigator) !== null && _navigator3 !== void 0 && _navigator3.webkitGetUserMedia || (_navigator4 = navigator) !== null && _navigator4 !== void 0 && _navigator4.mozGetUserMedia || (_navigator5 = navigator) !== null && _navigator5 !== void 0 && _navigator5.msGetUserMedia);
  var hasRTCDataChannel = !!((_window4 = window) !== null && _window4 !== void 0 && _window4.RTCDataChannel || (_window5 = window) !== null && _window5 !== void 0 && _window5.webkitRTCDataChannel || (_window6 = window) !== null && _window6 !== void 0 && _window6.mozRTCDataChannel);
  return hasRTCPeerConnection && hasGetUserMedia && hasRTCDataChannel;
};
function createPeerConnection() {
  var _window7, _window8, _window9;
  var RTCPeerConnectionConstructor = ((_window7 = window) === null || _window7 === void 0 ? void 0 : _window7.RTCPeerConnection) || ((_window8 = window) === null || _window8 === void 0 ? void 0 : _window8.webkitRTCPeerConnection) || ((_window9 = window) === null || _window9 === void 0 ? void 0 : _window9.mozRTCPeerConnection);
  if (RTCPeerConnectionConstructor) {
    return new RTCPeerConnectionConstructor();
  }
  return null;
}
var DEFAULT_TIMEOUT = 10000;

/**
 * Performs the actual SDP exchange.
 *
 * 1. Sends the SDP offer to the server,
 * 2. Awaits the server's offer.
 *
 * SDP describes what kind of media we can send and how the server and client communicate.
 *
 * https://developer.mozilla.org/en-US/docs/Glossary/SDP
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#name-protocol-operation
 *
 * Returns the URL of the post-redirect media server such that we may DELETE our session later
 */
function negotiateConnectionWithClientOffer(_x, _x2, _x3, _x4) {
  return _negotiateConnectionWithClientOffer.apply(this, arguments);
}

/**
 * Constructs the client's SDP offer
 *
 * SDP describes what kind of media we can send and how the server and client communicate.
 *
 * https://developer.mozilla.org/en-US/docs/Glossary/SDP
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#name-protocol-operation
 */
function _negotiateConnectionWithClientOffer() {
  _negotiateConnectionWithClientOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(peerConnection, endpoint, ofr, config) {
    var response, answerSDP, sdpLinkHeader, iceServers, offer, playheadUtc, errorMessage;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(peerConnection && endpoint && ofr)) {
              _context.next = 32;
              break;
            }
            _context.next = 3;
            return postSDPOffer(endpoint, ofr.sdp, config);
          case 3:
            response = _context.sent;
            if (!response.ok) {
              _context.next = 22;
              break;
            }
            _context.next = 7;
            return response.text();
          case 7:
            answerSDP = _context.sent;
            _context.next = 10;
            return peerConnection.setRemoteDescription(new RTCSessionDescription({
              type: 'answer',
              sdp: answerSDP
            }));
          case 10:
            sdpLinkHeader = response.headers.get('Link');
            iceServers = parseIceServersFromLinkHeader(sdpLinkHeader);
            peerConnection.setConfiguration({
              iceServers: iceServers
            });
            _context.next = 15;
            return peerConnection.createOffer();
          case 15:
            offer = _context.sent;
            _context.next = 18;
            return peerConnection.setLocalDescription(offer);
          case 18:
            playheadUtc = response.headers.get('Playhead-Utc');
            return _context.abrupt("return", {
              playhead: new Date(playheadUtc !== null && playheadUtc !== void 0 ? playheadUtc : new Date()),
              url: response.url
            });
          case 22:
            if (!(response.status === 406)) {
              _context.next = 26;
              break;
            }
            throw new Error(core.NOT_ACCEPTABLE_ERROR_MESSAGE);
          case 26:
            _context.next = 28;
            return response.text();
          case 28:
            errorMessage = _context.sent;
            throw new Error(errorMessage);
          case 30:
            _context.next = 33;
            break;
          case 32:
            throw new Error('Peer connection not defined.');
          case 33:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _negotiateConnectionWithClientOffer.apply(this, arguments);
}
function constructClientOffer(_x5) {
  return _constructClientOffer.apply(this, arguments);
}
function _constructClientOffer() {
  _constructClientOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(peerConnection) {
    var offer, ofr;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!peerConnection) {
              _context2.next = 12;
              break;
            }
            _context2.next = 3;
            return peerConnection.createOffer();
          case 3:
            offer = _context2.sent;
            _context2.next = 6;
            return peerConnection.setLocalDescription(offer);
          case 6:
            _context2.next = 8;
            return waitToCompleteICEGathering(peerConnection);
          case 8:
            ofr = _context2.sent;
            if (ofr) {
              _context2.next = 11;
              break;
            }
            throw Error('failed to gather ICE candidates for offer');
          case 11:
            return _context2.abrupt("return", ofr);
          case 12:
            return _context2.abrupt("return", null);
          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _constructClientOffer.apply(this, arguments);
}
function postSDPOffer(_x6, _x7, _x8) {
  return _postSDPOffer.apply(this, arguments);
}
/**
 * Receives an RTCPeerConnection and waits until
 * the connection is initialized or a timeout passes.
 *
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html#section-4.1
 * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState
 * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event
 */
function _postSDPOffer() {
  _postSDPOffer = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(endpoint, data, config) {
    var _config$sdpTimeout;
    var controller, id, url, response;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            controller = new AbortController();
            id = setTimeout(function () {
              return controller.abort();
            }, (_config$sdpTimeout = config === null || config === void 0 ? void 0 : config.sdpTimeout) !== null && _config$sdpTimeout !== void 0 ? _config$sdpTimeout : DEFAULT_TIMEOUT);
            if (config !== null && config !== void 0 && config.constant) {
              url = new URL(endpoint);
              url.searchParams.append('constant', 'true');
              endpoint = url.toString();
            }
            _context3.next = 5;
            return fetch__default["default"](endpoint, {
              method: 'POST',
              mode: 'cors',
              headers: {
                'content-type': 'application/sdp'
              },
              body: data,
              signal: controller.signal
            });
          case 5:
            response = _context3.sent;
            clearTimeout(id);
            return _context3.abrupt("return", response);
          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _postSDPOffer.apply(this, arguments);
}
function waitToCompleteICEGathering(_x9) {
  return _waitToCompleteICEGathering.apply(this, arguments);
}
/**
 * Parses the ICE servers from the `Link` headers returned during SDP negotiation.
 */
function _waitToCompleteICEGathering() {
  _waitToCompleteICEGathering = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee4(peerConnection) {
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", new Promise(function (resolve) {
              /** Wait at most five seconds for ICE gathering. */
              setTimeout(function () {
                resolve(peerConnection.localDescription);
              }, 5000);
              peerConnection.onicegatheringstatechange = function (_ev) {
                if (peerConnection.iceGatheringState === 'complete') {
                  resolve(peerConnection.localDescription);
                }
              };
            }));
          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _waitToCompleteICEGathering.apply(this, arguments);
}
function parseIceServersFromLinkHeader(iceString) {
  try {
    var _servers$length;
    var servers = iceString === null || iceString === void 0 ? void 0 : iceString.split(', ').map(function (serverStr) {
      var parts = serverStr.split(';').map(function (x) {
        return x.trim();
      }).filter(function (x) {
        return x;
      });
      var server = {
        urls: ''
      };
      var _iterator = createForOfIteratorHelper._createForOfIteratorHelper(parts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var part = _step.value;
          if (part.startsWith('stun:') || part.startsWith('turn:')) {
            server.urls = part;
          } else if (part.startsWith('username=')) {
            server.username = part.slice('username="'.length, -1);
          } else if (part.startsWith('credential=')) {
            server.credential = part.slice('credential="'.length, -1);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return server;
    }).filter(function (server) {
      return server.urls;
    });
    return servers && ((_servers$length = servers === null || servers === void 0 ? void 0 : servers.length) !== null && _servers$length !== void 0 ? _servers$length : 0) > 0 ? servers : [];
  } catch (e) {
    console.error(e);
  }
  return [];
}

/**
 * Client that uses WHEP to play back video over WebRTC.
 *
 * https://www.ietf.org/id/draft-murillo-whep-00.html
 */
var createNewWHEP = function createNewWHEP(source, element, callbacks, config) {
  var abortController = new AbortController();
  var peerConnection = null;
  var stream = new MediaStream();
  var errorComposed = function errorComposed(e) {
    var _callbacks$onError;
    if (element) {
      element.srcObject = null;
    }
    callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError = callbacks.onError) === null || _callbacks$onError === void 0 ? void 0 : _callbacks$onError.call(callbacks, e);
  };

  /**
   * Create a new WebRTC connection
   * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ice
   */
  peerConnection = createPeerConnection();
  if (peerConnection) {
    /** https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTransceiver */
    peerConnection.addTransceiver('video', {
      direction: 'recvonly'
    });
    peerConnection.addTransceiver('audio', {
      direction: 'recvonly'
    });

    /**
     * When new tracks are received in the connection, store local references,
     * so that they can be added to a MediaStream, and to the <video> element.
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/track_event
     */
    peerConnection.ontrack = /*#__PURE__*/function () {
      var _ref = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(event) {
        var track, currentTracks, streamAlreadyHasVideoTrack, streamAlreadyHasAudioTrack;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                if (!stream) {
                  _context.next = 18;
                  break;
                }
                track = event.track;
                currentTracks = stream.getTracks();
                streamAlreadyHasVideoTrack = currentTracks.some(function (track) {
                  return track.kind === 'video';
                });
                streamAlreadyHasAudioTrack = currentTracks.some(function (track) {
                  return track.kind === 'audio';
                });
                _context.t0 = track.kind;
                _context.next = _context.t0 === 'video' ? 9 : _context.t0 === 'audio' ? 13 : 17;
                break;
              case 9:
                if (!streamAlreadyHasVideoTrack) {
                  _context.next = 11;
                  break;
                }
                return _context.abrupt("break", 18);
              case 11:
                stream.addTrack(track);
                return _context.abrupt("break", 18);
              case 13:
                if (!streamAlreadyHasAudioTrack) {
                  _context.next = 15;
                  break;
                }
                return _context.abrupt("break", 18);
              case 15:
                stream.addTrack(track);
                return _context.abrupt("break", 18);
              case 17:
                console.log('got unknown track ' + track);
              case 18:
                _context.next = 23;
                break;
              case 20:
                _context.prev = 20;
                _context.t1 = _context["catch"](0);
                errorComposed(_context.t1);
              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 20]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    peerConnection.addEventListener('connectionstatechange', /*#__PURE__*/function () {
      var _ref2 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(_ev) {
        var _peerConnection, _peerConnection2, _callbacks$onConnecte;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                if (!(((_peerConnection = peerConnection) === null || _peerConnection === void 0 ? void 0 : _peerConnection.connectionState) === 'failed')) {
                  _context2.next = 3;
                  break;
                }
                throw new Error('Failed to connect to peer.');
              case 3:
                if (((_peerConnection2 = peerConnection) === null || _peerConnection2 === void 0 ? void 0 : _peerConnection2.connectionState) === 'connected' && !element.srcObject) {
                  element.srcObject = stream;
                  callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onConnecte = callbacks.onConnected) === null || _callbacks$onConnecte === void 0 ? void 0 : _callbacks$onConnecte.call(callbacks);
                }
                _context2.next = 9;
                break;
              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);
                errorComposed(_context2.t0);
              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 6]]);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    peerConnection.addEventListener('negotiationneeded', /*#__PURE__*/function () {
      var _ref3 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(_ev) {
        var ofr, response, currentDate, _callbacks$onPlayback;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return constructClientOffer(peerConnection);
              case 3:
                ofr = _context3.sent;
                _context3.next = 6;
                return negotiateConnectionWithClientOffer(peerConnection, source, ofr, config);
              case 6:
                response = _context3.sent;
                currentDate = Date.now();
                if (response !== null && response !== void 0 && response.playhead && currentDate) {
                  callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onPlayback = callbacks.onPlaybackOffsetUpdated) === null || _callbacks$onPlayback === void 0 ? void 0 : _callbacks$onPlayback.call(callbacks, currentDate - response.playhead.getTime());
                }
                _context3.next = 14;
                break;
              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](0);
                errorComposed(_context3.t0);
              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[0, 11]]);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());
  }
  return {
    destroy: function destroy() {
      var _abortController$abor, _peerConnection3, _peerConnection3$clos;
      abortController === null || abortController === void 0 ? void 0 : (_abortController$abor = abortController.abort) === null || _abortController$abor === void 0 ? void 0 : _abortController$abor.call(abortController);

      // Remove the WebRTC source
      if (element) {
        element.srcObject = null;
      }
      (_peerConnection3 = peerConnection) === null || _peerConnection3 === void 0 ? void 0 : (_peerConnection3$clos = _peerConnection3.close) === null || _peerConnection3$clos === void 0 ? void 0 : _peerConnection3$clos.call(_peerConnection3);
    }
  };
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/**
 * Client that uses WHIP to broadcast video over WebRTC.
 *
 * https://www.ietf.org/archive/id/draft-ietf-wish-whip-01.html
 */
var createNewWHIP = function createNewWHIP(ingestUrl, element, aspectRatio, callbacks, config) {
  var abortController = new AbortController();
  var peerConnection = null;
  var stream = null;
  var videoTransceiver = null;
  var audioTransceiver = null;
  var deleteUrl = null;
  var disconnectStream = null;

  /**
   * Create a new WebRTC connection
   * https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ice
   */
  peerConnection = createPeerConnection();
  if (peerConnection) {
    peerConnection.addEventListener('negotiationneeded', /*#__PURE__*/function () {
      var _ref = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee(_ev) {
        var _response$url, ofr, response, _callbacks$onError;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return constructClientOffer(peerConnection);
              case 3:
                ofr = _context.sent;
                _context.next = 6;
                return negotiateConnectionWithClientOffer(peerConnection, ingestUrl, ofr, config);
              case 6:
                response = _context.sent;
                deleteUrl = (_response$url = response === null || response === void 0 ? void 0 : response.url) !== null && _response$url !== void 0 ? _response$url : null;
                _context.next = 13;
                break;
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](0);
                callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError = callbacks.onError) === null || _callbacks$onError === void 0 ? void 0 : _callbacks$onError.call(callbacks, _context.t0);
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 10]]);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    peerConnection.addEventListener('connectionstatechange', /*#__PURE__*/function () {
      var _ref2 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee2(_ev) {
        var _peerConnection, _peerConnection2, _callbacks$onConnecte, _callbacks$onError2;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                if (!(((_peerConnection = peerConnection) === null || _peerConnection === void 0 ? void 0 : _peerConnection.connectionState) === 'failed')) {
                  _context2.next = 3;
                  break;
                }
                throw new Error('Failed to connect to peer.');
              case 3:
                if (((_peerConnection2 = peerConnection) === null || _peerConnection2 === void 0 ? void 0 : _peerConnection2.connectionState) === 'connected' && stream && audioTransceiver && videoTransceiver) {
                  element.srcObject = stream;
                  callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onConnecte = callbacks.onConnected) === null || _callbacks$onConnecte === void 0 ? void 0 : _callbacks$onConnecte.call(callbacks, {
                    stream: stream,
                    videoTransceiver: videoTransceiver,
                    audioTransceiver: audioTransceiver
                  });
                }
                _context2.next = 9;
                break;
              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);
                callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError2 = callbacks.onError) === null || _callbacks$onError2 === void 0 ? void 0 : _callbacks$onError2.call(callbacks, _context2.t0);
              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[0, 6]]);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    /**
     * While the connection is being initialized, ask for camera and microphone permissions and
     * add video and audio tracks to the peerConnection.
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
     */
    navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    }).then( /*#__PURE__*/function () {
      var _ref3 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee3(mediaStream) {
        var _mediaStream$getVideo, _mediaStream$getVideo2, _mediaStream$getVideo3, _mediaStream$getAudio, _mediaStream$getAudio2, _mediaStream$getAudio3;
        var newVideoTrack, newAudioTrack, _peerConnection$addTr, _peerConnection3, _peerConnection$addTr2, _peerConnection4;
        return asyncToGenerator._regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                newVideoTrack = (_mediaStream$getVideo = mediaStream === null || mediaStream === void 0 ? void 0 : (_mediaStream$getVideo2 = mediaStream.getVideoTracks) === null || _mediaStream$getVideo2 === void 0 ? void 0 : (_mediaStream$getVideo3 = _mediaStream$getVideo2.call(mediaStream)) === null || _mediaStream$getVideo3 === void 0 ? void 0 : _mediaStream$getVideo3[0]) !== null && _mediaStream$getVideo !== void 0 ? _mediaStream$getVideo : null;
                newAudioTrack = (_mediaStream$getAudio = mediaStream === null || mediaStream === void 0 ? void 0 : (_mediaStream$getAudio2 = mediaStream.getAudioTracks) === null || _mediaStream$getAudio2 === void 0 ? void 0 : (_mediaStream$getAudio3 = _mediaStream$getAudio2.call(mediaStream)) === null || _mediaStream$getAudio3 === void 0 ? void 0 : _mediaStream$getAudio3[0]) !== null && _mediaStream$getAudio !== void 0 ? _mediaStream$getAudio : null;
                if (!newVideoTrack) {
                  _context3.next = 6;
                  break;
                }
                _context3.next = 5;
                return newVideoTrack.applyConstraints(getConstraints(aspectRatio !== null && aspectRatio !== void 0 ? aspectRatio : '16to9'));
              case 5:
                videoTransceiver = (_peerConnection$addTr = (_peerConnection3 = peerConnection) === null || _peerConnection3 === void 0 ? void 0 : _peerConnection3.addTransceiver(newVideoTrack, {
                  direction: 'sendonly'
                })) !== null && _peerConnection$addTr !== void 0 ? _peerConnection$addTr : null;
              case 6:
                if (newAudioTrack) {
                  audioTransceiver = (_peerConnection$addTr2 = (_peerConnection4 = peerConnection) === null || _peerConnection4 === void 0 ? void 0 : _peerConnection4.addTransceiver(newAudioTrack, {
                    direction: 'sendonly'
                  })) !== null && _peerConnection$addTr2 !== void 0 ? _peerConnection$addTr2 : null;
                }
                stream = mediaStream;
              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }()).catch(function (e) {
      var _callbacks$onError3;
      return callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError3 = callbacks.onError) === null || _callbacks$onError3 === void 0 ? void 0 : _callbacks$onError3.call(callbacks, e);
    });
    disconnectStream = function disconnectStream() {
      if (!deleteUrl) {
        return;
      }
      fetch__default["default"](deleteUrl, {
        method: 'DELETE',
        mode: 'cors'
      }).catch(function (e) {
        var _callbacks$onError4;
        return callbacks === null || callbacks === void 0 ? void 0 : (_callbacks$onError4 = callbacks.onError) === null || _callbacks$onError4 === void 0 ? void 0 : _callbacks$onError4.call(callbacks, e);
      });
    };
  }
  return {
    destroy: function destroy() {
      var _disconnectStream, _abortController$abor, _peerConnection5, _peerConnection5$clos, _stream$getTracks, _stream, _stream$getTracks2;
      (_disconnectStream = disconnectStream) === null || _disconnectStream === void 0 ? void 0 : _disconnectStream();
      abortController === null || abortController === void 0 ? void 0 : (_abortController$abor = abortController.abort) === null || _abortController$abor === void 0 ? void 0 : _abortController$abor.call(abortController);

      // Remove the WebRTC source
      if (element) {
        element.srcObject = null;
      }
      (_peerConnection5 = peerConnection) === null || _peerConnection5 === void 0 ? void 0 : (_peerConnection5$clos = _peerConnection5.close) === null || _peerConnection5$clos === void 0 ? void 0 : _peerConnection5$clos.call(_peerConnection5);

      // Stop using the local camera and microphone
      var tracks = (_stream$getTracks = (_stream = stream) === null || _stream === void 0 ? void 0 : (_stream$getTracks2 = _stream.getTracks) === null || _stream$getTracks2 === void 0 ? void 0 : _stream$getTracks2.call(_stream)) !== null && _stream$getTracks !== void 0 ? _stream$getTracks : [];
      var _iterator = createForOfIteratorHelper._createForOfIteratorHelper(tracks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _track$stop;
          var track = _step.value;
          track === null || track === void 0 ? void 0 : (_track$stop = track.stop) === null || _track$stop === void 0 ? void 0 : _track$stop.call(track);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  };
};

/**
 * Ask for camera and microphone permissions and add video and audio tracks to the peerConnection.
 * If a media stream is passed in, use this for the connection.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */
var changeMediaStream = /*#__PURE__*/function () {
  var _ref5 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee4(_ref4) {
    var _prevMediaStream$getV, _prevMediaStream$getV2, _prevMediaStream$getV3, _prevMediaStream$getA, _prevMediaStream$getA2, _prevMediaStream$getA3, _newMediaStream$getVi, _newMediaStream$getVi2, _newMediaStream$getVi3, _newMediaStream$getAu, _newMediaStream$getAu2, _newMediaStream$getAu3;
    var newMediaStream, prevMediaStream, aspectRatio, element, onConnected, videoTransceiver, audioTransceiver, prevVideoTrack, prevAudioTrack, newVideoTrack, newAudioTrack, _prevVideoTrack$enabl, _prevAudioTrack$enabl;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            newMediaStream = _ref4.newMediaStream, prevMediaStream = _ref4.prevMediaStream, aspectRatio = _ref4.aspectRatio, element = _ref4.element, onConnected = _ref4.onConnected, videoTransceiver = _ref4.videoTransceiver, audioTransceiver = _ref4.audioTransceiver;
            prevVideoTrack = (_prevMediaStream$getV = prevMediaStream === null || prevMediaStream === void 0 ? void 0 : (_prevMediaStream$getV2 = prevMediaStream.getVideoTracks) === null || _prevMediaStream$getV2 === void 0 ? void 0 : (_prevMediaStream$getV3 = _prevMediaStream$getV2.call(prevMediaStream)) === null || _prevMediaStream$getV3 === void 0 ? void 0 : _prevMediaStream$getV3[0]) !== null && _prevMediaStream$getV !== void 0 ? _prevMediaStream$getV : null;
            prevAudioTrack = (_prevMediaStream$getA = prevMediaStream === null || prevMediaStream === void 0 ? void 0 : (_prevMediaStream$getA2 = prevMediaStream.getAudioTracks) === null || _prevMediaStream$getA2 === void 0 ? void 0 : (_prevMediaStream$getA3 = _prevMediaStream$getA2.call(prevMediaStream)) === null || _prevMediaStream$getA3 === void 0 ? void 0 : _prevMediaStream$getA3[0]) !== null && _prevMediaStream$getA !== void 0 ? _prevMediaStream$getA : null;
            newVideoTrack = (_newMediaStream$getVi = newMediaStream === null || newMediaStream === void 0 ? void 0 : (_newMediaStream$getVi2 = newMediaStream.getVideoTracks) === null || _newMediaStream$getVi2 === void 0 ? void 0 : (_newMediaStream$getVi3 = _newMediaStream$getVi2.call(newMediaStream)) === null || _newMediaStream$getVi3 === void 0 ? void 0 : _newMediaStream$getVi3[0]) !== null && _newMediaStream$getVi !== void 0 ? _newMediaStream$getVi : null;
            newAudioTrack = (_newMediaStream$getAu = newMediaStream === null || newMediaStream === void 0 ? void 0 : (_newMediaStream$getAu2 = newMediaStream.getAudioTracks) === null || _newMediaStream$getAu2 === void 0 ? void 0 : (_newMediaStream$getAu3 = _newMediaStream$getAu2.call(newMediaStream)) === null || _newMediaStream$getAu3 === void 0 ? void 0 : _newMediaStream$getAu3[0]) !== null && _newMediaStream$getAu !== void 0 ? _newMediaStream$getAu : null;
            if (!newVideoTrack) {
              _context4.next = 11;
              break;
            }
            _context4.next = 8;
            return newVideoTrack.applyConstraints(getConstraints(aspectRatio));
          case 8:
            _context4.next = 10;
            return videoTransceiver.sender.replaceTrack(newVideoTrack);
          case 10:
            newVideoTrack.enabled = (_prevVideoTrack$enabl = prevVideoTrack === null || prevVideoTrack === void 0 ? void 0 : prevVideoTrack.enabled) !== null && _prevVideoTrack$enabl !== void 0 ? _prevVideoTrack$enabl : true;
          case 11:
            if (!newAudioTrack) {
              _context4.next = 15;
              break;
            }
            _context4.next = 14;
            return audioTransceiver.sender.replaceTrack(newAudioTrack);
          case 14:
            newAudioTrack.enabled = (_prevAudioTrack$enabl = prevAudioTrack === null || prevAudioTrack === void 0 ? void 0 : prevAudioTrack.enabled) !== null && _prevAudioTrack$enabl !== void 0 ? _prevAudioTrack$enabl : true;
          case 15:
            element.srcObject = newMediaStream;
            onConnected({
              stream: newMediaStream,
              videoTransceiver: videoTransceiver,
              audioTransceiver: audioTransceiver
            });
          case 17:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return function changeMediaStream(_x4) {
    return _ref5.apply(this, arguments);
  };
}();

/**
 * Ask for camera and microphone permissions and get the MediaStream for the given constraints.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
 */
var getUserMedia = /*#__PURE__*/function () {
  var _ref7 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee5(_ref6) {
    var source, _navigator, _navigator$mediaDevic, _source$streamConstra, _source$streamConstra2, _source$streamConstra3, _source$streamConstra4, newMediaStream;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            source = _ref6.source;
            _context5.prev = 1;
            _context5.next = 4;
            return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : _navigator$mediaDevic.getUserMedia(asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, _typeof(source.streamConstraints) === 'object' ? source.streamConstraints : {}), {}, {
              video: asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, typeof ((_source$streamConstra = source.streamConstraints) === null || _source$streamConstra === void 0 ? void 0 : _source$streamConstra.video) !== 'boolean' ? (_source$streamConstra2 = source.streamConstraints) === null || _source$streamConstra2 === void 0 ? void 0 : _source$streamConstra2.video : {}), source !== null && source !== void 0 && source.videoDeviceId ? {
                deviceId: source === null || source === void 0 ? void 0 : source.videoDeviceId
              } : {}),
              audio: asyncToGenerator._objectSpread2(asyncToGenerator._objectSpread2({}, typeof ((_source$streamConstra3 = source.streamConstraints) === null || _source$streamConstra3 === void 0 ? void 0 : _source$streamConstra3.audio) !== 'boolean' ? (_source$streamConstra4 = source.streamConstraints) === null || _source$streamConstra4 === void 0 ? void 0 : _source$streamConstra4.audio : {}), source !== null && source !== void 0 && source.audioDeviceId ? {
                deviceId: source === null || source === void 0 ? void 0 : source.audioDeviceId
              } : {})
            }));
          case 4:
            newMediaStream = _context5.sent;
            return _context5.abrupt("return", newMediaStream !== null && newMediaStream !== void 0 ? newMediaStream : null);
          case 8:
            _context5.prev = 8;
            _context5.t0 = _context5["catch"](1);
            console.error(_context5.t0);
            return _context5.abrupt("return", null);
          case 12:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[1, 8]]);
  }));
  return function getUserMedia(_x5) {
    return _ref7.apply(this, arguments);
  };
}();
var getMediaDevices = function getMediaDevices(onDevicesUpdated) {
  var _navigator2, _navigator2$mediaDevi;
  if (typeof navigator !== 'undefined' && (_navigator2 = navigator) !== null && _navigator2 !== void 0 && (_navigator2$mediaDevi = _navigator2.mediaDevices) !== null && _navigator2$mediaDevi !== void 0 && _navigator2$mediaDevi.enumerateDevices) {
    var onDeviceChange = function onDeviceChange() {
      navigator.mediaDevices.enumerateDevices().then(function (devices) {
        return onDevicesUpdated(devices);
      });
    };
    navigator.mediaDevices.addEventListener('devicechange', onDeviceChange);
    onDeviceChange();
    return function () {
      navigator.mediaDevices.removeEventListener('devicechange', onDeviceChange);
    };
  }
  return function () {
    //
  };
};
var getDisplayMedia = /*#__PURE__*/function () {
  var _ref8 = asyncToGenerator._asyncToGenerator( /*#__PURE__*/asyncToGenerator._regeneratorRuntime().mark(function _callee6(options) {
    var _navigator3, _navigator3$mediaDevi, mediaStream;
    return asyncToGenerator._regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            if (!(typeof navigator !== 'undefined' && (_navigator3 = navigator) !== null && _navigator3 !== void 0 && (_navigator3$mediaDevi = _navigator3.mediaDevices) !== null && _navigator3$mediaDevi !== void 0 && _navigator3$mediaDevi.getDisplayMedia)) {
              _context6.next = 6;
              break;
            }
            _context6.next = 4;
            return navigator.mediaDevices.getDisplayMedia(options);
          case 4:
            mediaStream = _context6.sent;
            return _context6.abrupt("return", mediaStream);
          case 6:
            _context6.next = 11;
            break;
          case 8:
            _context6.prev = 8;
            _context6.t0 = _context6["catch"](0);
            console.error(_context6.t0);
          case 11:
            return _context6.abrupt("return", null);
          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[0, 8]]);
  }));
  return function getDisplayMedia(_x6) {
    return _ref8.apply(this, arguments);
  };
}();
var getConstraints = function getConstraints(aspectRatio) {
  var constraints = {
    width: {
      ideal: 1280
    },
    height: {
      ideal: 720
    },
    aspectRatio: {
      ideal: aspectRatio === '9to16' ? 9 / 16 : aspectRatio === '1to1' ? 1 : aspectRatio === '21to9' ? 21 / 9 : aspectRatio === '4to5' ? 4 / 5 : 16 / 9
    }
  };
  return constraints;
};

exports.changeMediaStream = changeMediaStream;
exports.createNewWHEP = createNewWHEP;
exports.createNewWHIP = createNewWHIP;
exports.getDisplayMedia = getDisplayMedia;
exports.getMediaDevices = getMediaDevices;
exports.getUserMedia = getUserMedia;
exports.isWebRTCSupported = isWebRTCSupported;
